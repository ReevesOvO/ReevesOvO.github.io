{"name":"javascript","slug":"javascript","count":4,"postlist":[{"title":"JavaScript-单例模式","slug":"javascriptsingleton","date":"2018-07-06T16:19:04.000Z","updated":"2018-10-02T15:01:49.428Z","comments":true,"path":"api/articles/javascriptsingleton.json","excerpt":"<p>JavaScript单例模式  </p>\n<hr>\n<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><p>&emsp;&emsp;单例模式时一种较为简单的设计模式，传统的单例模式是指保证一个类只有一个实例，并提供一个访问它的全局访问点。  </p>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>&emsp;&emsp;实现的思路是定义一个变量标志是否已经创建过实例，如果已经有实例，则返回该实例对象，否则创建一个实例并返回。用一个创建登录框的例子来说明单例模式在JavaScript中如何实现：  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> loginHtml = <span class=\"string\">\"账号：&lt;input type=\\\"text\\\" /&gt;&lt;br/&gt;密码：&lt;input type=\\\"password\\\" /&gt;\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> createLoginDiv = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">html</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.html = html;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.init();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">createLoginDiv.prototype.init = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> div = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'div'</span>);</span><br><span class=\"line\">  div.innerHTML = <span class=\"keyword\">this</span>.html;</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.body.appendChild(div);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">createLoginDiv.getInstance = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> instance = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">html</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">new</span> createLoginDiv(html);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"><span class=\"keyword\">var</span> div1 = createLoginDiv.getInstance(loginHtml);</span><br><span class=\"line\"><span class=\"keyword\">var</span> div2 = createLoginDiv.getInstance(<span class=\"string\">\"账号密码\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(div1 === div2); <span class=\"comment\">// true 并且页面只有一个登录框，为第一次创建的。</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这样实现的单例模式耦合度较低，init只负责创建登录框对象，对于返回现有对象还是创建新对象交给getInstance去做，代码也很清晰。通过这样的方式我们想要在页面上只想要一个登录框时可以得到保证，只有一个登录框，不会重复创建，节约性能。</p>\n<h3 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h3><h3 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3>","keywords":null,"cover":null,"content":null,"text":"JavaScript单例模式  单例模式&emsp;&emsp;单例模式时一种较为简单的设计模式，传统的单例模式是指保证一个类只有一个实例，并提供一个访问它的全局访问点。  实现&emsp;&emsp;实现的思路是定义一个变量标志是否已经创建过实例，如果已经有实例，则返回该实例对","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":4,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":2,"path":"api/tags/javascript.json"},{"name":"singleton","slug":"singleton","count":1,"path":"api/tags/singleton.json"}]},{"title":"【转载】深入理解JavaScript事件循环(Eventloop)和microtask","slug":"eventloop","date":"2018-05-27T06:10:37.000Z","updated":"2018-10-02T15:01:49.427Z","comments":true,"path":"api/articles/eventloop.json","excerpt":"<p><strong>在做javascript练习题或者面试的时候，总会遇到下面这样的题目：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"1\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"2\"</span>);</span><br><span class=\"line\">  &#125;,<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"3\"</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"4\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 控制台输出1 4 3 2</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;想知道为什么是这样的结果，就必须理解javascript的eventloop机制，推荐这位博主DongXu的两篇文章，这里就不转载全文了，推荐大家去他的博客看，还有生动的demo，很容易懂。</p>\n<blockquote>\n<p><a href=\"http://www.cnblogs.com/dong-xu/p/7000163.html\" target=\"_blank\" rel=\"noopener\">深入理解 JavaScript 事件循环（一）— event loop</a> </p>\n<p><a href=\"http://www.cnblogs.com/dong-xu/p/7000139.html\" target=\"_blank\" rel=\"noopener\">[译]深入理解 JavaScript 事件循环（二）— task and microtask</a></p>\n</blockquote>\n","keywords":null,"cover":null,"content":null,"text":"在做javascript练习题或者面试的时候，总会遇到下面这样的题目：1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br> console.log(\"1\");<br><br>  setTimeo","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":4,"path":"api/categories/javascript.json"}],"tags":[{"name":"eventloop","slug":"eventloop","count":1,"path":"api/tags/eventloop.json"},{"name":"事件循环","slug":"事件循环","count":1,"path":"api/tags/事件循环.json"}]},{"title":"原生javascript实现canvas图形验证码","slug":"javascript-canvas-verify-code","date":"2018-10-14T12:24:50.000Z","updated":"2018-10-14T16:34:19.524Z","comments":true,"path":"api/articles/javascript-canvas-verify-code.json","excerpt":"<p>&emsp;&emsp;感觉自己最近好像很少拿原生js写东西了，自己的js水平也还有待提高。上周做原型设计的时候设计了一个图形验证码，感觉这么小一个东西也没必要去找个库，就打算自己造个小轮子来用了。</p>\n<p>&emsp;&emsp;图形验证码的作用是一种人机识别的手段，目的是为了区分正常人和机器人，所以没必要设计的太麻烦(12306之前的验证码简直!!)，所以就采用数字+大小写字母共4个字符进行验证，用canvas进行绘制，如果只是简单这样也太简单了，像接触到的其他网站使用的验证码还有背景色和干扰的线条，基本上这就是实现的思路了。</p>\n<hr>\n<p>&emsp;&emsp;根据实现的思路，随机颜色的方法、生成随机数的方法肯定是需要的。</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 生成一个随机数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">function randomNum(<span class=\"built_in\">min</span>, <span class=\"built_in\">max</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Math.<span class=\"built_in\">floor</span>(Math.<span class=\"built_in\">random</span>() * (<span class=\"built_in\">max</span> - <span class=\"built_in\">min</span>) + <span class=\"built_in\">min</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 生成随机颜色rgb值</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">function randomColor(<span class=\"built_in\">min</span>, <span class=\"built_in\">max</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> r = randomNum(<span class=\"built_in\">min</span>, <span class=\"built_in\">max</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> g = randomNum(<span class=\"built_in\">min</span>, <span class=\"built_in\">max</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> b = randomNum(<span class=\"built_in\">min</span>, <span class=\"built_in\">max</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> `rgb($&#123;r&#125;, $&#123;g&#125;, $&#123;b&#125;)`;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>&emsp;&emsp;在html我们只要需要提供一个容器就可以了，调用时传容器id，以及图形验证码的size就可以了。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"verifyContainer\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;获取到容器和size之后，我们得先添加一个canvas，参考了下网上其他验证码的背景色大概都在160-240左右可能这个区间的颜色会偏浅一点。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 向html添加canvas</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">appendCanvas</span>(<span class=\"params\">id, width, height</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> container = <span class=\"built_in\">document</span>.getElementById(id);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> canvas = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'canvas'</span>);</span><br><span class=\"line\">    canvas.width = width;</span><br><span class=\"line\">    canvas.height = height;</span><br><span class=\"line\">    canvas.style.backgroundColor = randomColor(<span class=\"number\">160</span>, <span class=\"number\">240</span>);</span><br><span class=\"line\">    container.appendChild(canvas);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","keywords":null,"cover":null,"content":null,"text":"&emsp;&emsp;感觉自己最近好像很少拿原生js写东西了，自己的js水平也还有待提高。上周做原型设计的时候设计了一个图形验证码，感觉这么小一个东西也没必要去找个库，就打算自己造个小轮子来用了。&emsp;&emsp;图形验证码的作用是一种人机识别的手段，目的是为了区分正常人","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":4,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":2,"path":"api/tags/javascript.json"},{"name":"验证码","slug":"验证码","count":1,"path":"api/tags/验证码.json"}]},{"title":"原型链与继承-JS高级","slug":"the-proptotype-chain-and-inheritance","date":"2018-09-24T04:42:15.000Z","updated":"2018-10-02T15:01:49.428Z","comments":true,"path":"api/articles/the-proptotype-chain-and-inheritance.json","excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>&emsp;&emsp;初学javascript的时候对原型链和继承就一知半解，上半年复习的时候感觉十分良好，直到最近又被问道的时候，还是讲不清楚。自己就又看了一遍JS高级程序设计，力求有更深的理解，彻底搞懂。</p>\n<p>&emsp;&emsp;继承是OO语言中的一个最为人津津乐道的概念。许多OO语言都支持两种继承方式：接口继承和 实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。由于js中方法没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而且其 实现继承主要是依靠原型链来实现的。本段摘自JS高级程序设计。</p>\n<h2 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h2><p>&emsp;&emsp;原型和实例关系：</p>\n<blockquote>\n<p>每个构造函数(constructor)都有一个原型对象(prototype)，原型对象都包含一个指向构造函数的指针，而实例(instance)都包含一个只想原型对象的内部指针。</p>\n</blockquote>\n<p>&emsp;&emsp;如果试图引用对象(instance)的某个属性，首先会在对象内部有没有这个属性，找不到时才会在该对象的原型(prototype)里去寻找这个属性。</p>\n<p>&emsp;&emsp;让一个实例的原型对象指向另一个类型的实例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">thisConstructor.prototype = otherInstance</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们如果要引用thisConstructor构造的实例thisInstance的属性name，</p>","keywords":null,"cover":null,"content":null,"text":"前言&emsp;&emsp;初学javascript的时候对原型链和继承就一知半解，上半年复习的时候感觉十分良好，直到最近又被问道的时候，还是讲不清楚。自己就又看了一遍JS高级程序设计，力求有更深的理解，彻底搞懂。&emsp;&emsp;继承是OO语言中的一个最为人津津乐道的概念","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":4,"path":"api/categories/javascript.json"}],"tags":[{"name":"原型链","slug":"原型链","count":1,"path":"api/tags/原型链.json"},{"name":"继承","slug":"继承","count":1,"path":"api/tags/继承.json"}]}]}