{"title":"TypeScript泛型","slug":"typescript-generics","date":"2018-11-04T08:00:26.000Z","updated":"2018-11-05T16:08:47.855Z","comments":true,"path":"api/articles/typescript-generics.json","photos":[],"link":"","excerpt":"前言&emsp;&emsp;之前上手typescript+vue的时候，vue也没有完全支持typescript，当时看typescript的文档的时候，就大概的过了一遍。当时也不是很清楚如何在vue中使用typescript，更别说泛型了。&emsp;&emsp;软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。&emsp;&emsp;这是typescript官方文档的介绍，个人感觉不是太好理解，个人理解这里的组件更多的是指方法，官方的泛型示例也都是跟方法相关的。泛型1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>// 无返回值<br>function doSomething(obj: any): void &#123;<br>\t// do something<br>&#125;<br>// 有返回值<br>function getSomething(obj: any): any &#123;<br>\treturn obj;<br>&#125;<br>&emsp;&emsp;我在vue中就只使用了这两种，说起来也是尴尬，typescript的真正功力都没发挥出来，把typescript写成了javascript，还多堆了两个关键词的代码。其实之前在写的时候就有发现所有具有返回值的方法都指定any有何意义呢。&emsp;&emsp;typescript的基础类型也很多，如果一个方法接受一个参数直接进行返回，如果要用上强类型，是否需要写多个方法，仅仅是指定类型的不同，答案是否定的。一个方法能够接受任意类型的参数并返回相应类型的参数，就是泛型。泛型方法：1<br>2<br>3<br>function identity&lt;T&gt;(arg: T): T &#123;<br>\treturn T;<br>&#125;<br>identity方法就是泛型，它接受任意类型的参数，并可以对参数类型进行捕获，并将捕获的类型返回。这样的identity可以适用多个类型。定义了泛型方法之后，有两种方法可以进行使用，一种是传入参数和类型，第二种是使用类型推论：","covers":null,"content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>&emsp;&emsp;之前上手typescript+vue的时候，vue也没有完全支持typescript，当时看typescript的文档的时候，就大概的过了一遍。当时也不是很清楚如何在vue中使用typescript，更别说泛型了。</p>\n<p>&emsp;&emsp;<em>软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</em></p>\n<p>&emsp;&emsp;这是typescript官方文档的介绍，个人感觉不是太好理解，个人理解这里的组件更多的是指方法，官方的泛型示例也都是跟方法相关的。</p>\n<h4 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 无返回值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\">obj: <span class=\"built_in\">any</span></span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 有返回值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getSomething</span>(<span class=\"params\">obj: <span class=\"built_in\">any</span></span>): <span class=\"title\">any</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我在vue中就只使用了这两种，说起来也是尴尬，typescript的真正功力都没发挥出来，把typescript写成了javascript，还多堆了两个关键词的代码。其实之前在写的时候就有发现所有具有返回值的方法都指定any有何意义呢。</p>\n<p>&emsp;&emsp;typescript的基础类型也很多，如果一个方法接受一个参数直接进行返回，如果要用上强类型，是否需要写多个方法，仅仅是指定类型的不同，答案是否定的。一个方法能够接受任意类型的参数并返回相应类型的参数，就是泛型。泛型方法：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> T;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>identity</code>方法就是泛型，它接受任意类型的参数，并可以对参数类型进行捕获，并将捕获的类型返回。这样的<code>identity</code>可以适用多个类型。定义了泛型方法之后，有两种方法可以进行使用，一种是传入参数和类型，第二种是使用类型推论：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 传入参数和类型 T就是string</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> out = identity&lt;<span class=\"built_in\">string</span>&gt;(<span class=\"string\">\"string\"</span>); <span class=\"comment\">// type: string</span></span><br><span class=\"line\"><span class=\"comment\">//类型推论 T会根据参数类型推断为number</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> out = identity&lt;<span class=\"built_in\">number</span>&gt;(<span class=\"number\">10</span>); <span class=\"comment\">// type: number</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;使用泛型变量时需要注意，如果不具体指定传入参数的具体类型如数组、对象，就直接使用数组或对象的方法会报错。因为类型变量代表的是任意类型，传入的参数可能是数字、布尔值等，此时我们要使用<code>length</code>查看其长度是不行的，因为都不具有length属性。如果是数组，需要在泛型的基础上指定为数组。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T[]</span>): <span class=\"title\">T</span>[] </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> arg.length;\t<span class=\"comment\">// ok</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// or</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: <span class=\"built_in\">Array</span>&lt;T&gt;</span>): <span class=\"title\">Array</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> arg.length; <span class=\"comment\">// ok</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建泛型\"><a href=\"#创建泛型\" class=\"headerlink\" title=\"创建泛型\"></a>创建泛型</h4><p>&emsp;&emsp;在普通方法声明的基础上加一个类型参数，这里的参数名T可以是任意的，而且使用时只要数量对的上就行。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;使用对象字面量进行创建，在此基础上也可以抽象成接口：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myIdentity: &#123;&lt;T&gt;(arg: T): T&#125; = identity;</span><br><span class=\"line\"><span class=\"comment\">// or</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> GenericFunction &#123;</span><br><span class=\"line\">    &lt;T&gt;(arg: T): T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myIdentity: GenericFunction = identity;</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><p>&emsp;&emsp;主要在使用上，如果一个方法需要适配不同类型的传入参数，就可以使用泛型定义方法。这种使用方式就如identity方法一样，根据传入参数不同返回指定类型的参数。</p>\n<p>&emsp;&emsp;另外就是指定请求参数类型。如axios请求：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.post&lt;T&gt;(<span class=\"string\">`<span class=\"subst\">$&#123;url&#125;</span>`</span>, params)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;还有就是定义请求返回数据的类型，这样我们就可以在ide中使用<code>.</code>运算符拿到response中的属性。<br><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> LoginRequest &#123;</span><br><span class=\"line\">    username: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    password: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> LoginPayload &#123;</span><br><span class=\"line\">    username: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    token: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    ···</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> Login = <span class=\"keyword\">async</span> (loginParams: LoginRequest): <span class=\"built_in\">Promise</span>&lt;LoginPayload&gt; =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> http.post&lt;LoginRequest&gt;(<span class=\"string\">'/login'</span>, loginParams);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> response.data <span class=\"keyword\">as</span> LoginPayload;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span>(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;代码中定义了两个接口，分别为登陆的请求参数类型，和登陆返回值类型。在return的时候使用as断言。这样在请求得到的返回结果，在ide中就可以使用<code>.</code>得到返回结果中的token等属性，比较方便，不需要将请求结果打印出来，或者查看请求结果。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>&emsp;&emsp; 除此之外还有泛型类和类类型，于方法类似，只不过是换成了类的写法，而且不常用。对于学习新的语言或者框架使用粗略的过一遍文档，然后就上手做，肯定开始很多东西都不了解。就像我之前写的，感觉完全没有用上typescript的强类型，把ts写成了js。不过这种学习的方式好的一点是，在了解过后，写了一段时间代码，也踩过一些坑之后，再次学习的话，就有醍醐灌顶、豁然开朗的感觉，记忆也会更加深刻。了解清楚了泛型的使用，现在也可以去更正之前代码的错误，加上泛型或指定其类型。</p>\n","categories":[{"name":"TypeScript","slug":"TypeScript","count":1,"path":"api/categories/TypeScript.json"}],"tags":[{"name":"TypeScript","slug":"TypeScript","count":1,"path":"api/tags/TypeScript.json"},{"name":"Generics","slug":"Generics","count":1,"path":"api/tags/Generics.json"}]}