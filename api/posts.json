{"total":18,"pageSize":10,"pageCount":2,"data":[{"title":"使用charles进行APP抓包","slug":"use-charles","date":"2018-10-07T07:32:04.000Z","updated":"2018-10-07T15:02:32.649Z","comments":true,"path":"api/articles/use-charles.json","excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>&emsp;&emsp;本来想趁国庆写个小工具来自动预约单车，手动确实太麻烦了，时间掌握不好，车就被别人骑走了。做这个小工具最重要的步骤就是抓到摩拜和哈罗的api，选择了charles这款抓包工具，是挺好用的，不够也需要付费。</p>\n<p>&emsp;&emsp;之前定好的计划一点点被打乱，高速一日游这种就不说了t.t，结果用charles抓包才发现好像别人也不傻，api都是加密的，导致小工具就暂时搁置了。那么就先来记录下如何使用charles抓取app的api吧。</p>\n<h2 id=\"PC设置\"><a href=\"#PC设置\" class=\"headerlink\" title=\"PC设置\"></a>PC设置</h2><p>&emsp;&emsp;开始之前得保证你下载并安装了charles，有关如何安装就不赘述了，另外得保证wifi环境下。</p>\n<p><img src=\"https://i.loli.net/2018/10/07/5bba1be006793.png\" alt=\"proxy设置\"></p>\n<p>&emsp;&emsp;Step1: 点击proxy settings进行代理设置，填上代理端口号默认是8888，激活http代理。</p>\n<p><img src=\"https://i.loli.net/2018/10/07/5bba1be032586.png\" alt=\"proxy mobile\"></p>\n<p>&emsp;&emsp;Step2: 因为只需要抓手机APP，所以不需要代理pc，将macOS Proxy勾选去掉。</p>\n<h2 id=\"手机设置\"><a href=\"#手机设置\" class=\"headerlink\" title=\"手机设置\"></a>手机设置</h2>","keywords":null,"cover":"https://i.loli.net/2018/10/07/5bba1be006793.png","content":null,"text":"前言&emsp;&emsp;本来想趁国庆写个小工具来自动预约单车，手动确实太麻烦了，时间掌握不好，车就被别人骑走了。做这个小工具最重要的步骤就是抓到摩拜和哈罗的api，选择了charles这款抓包工具，是挺好用的，不够也需要付费。&emsp;&emsp;之前定好的计划一点点被打乱","link":"","raw":null,"photos":[],"categories":[{"name":"抓包","slug":"抓包","count":1,"path":"api/categories/抓包.json"}],"tags":[{"name":"charles","slug":"charles","count":1,"path":"api/tags/charles.json"},{"name":"抓包","slug":"抓包","count":1,"path":"api/tags/抓包.json"}]},{"title":"Git权威指南读书笔记","slug":"definitity-guide-of-git","date":"2018-10-07T04:21:04.000Z","updated":"2018-10-07T13:33:06.612Z","comments":true,"path":"api/articles/definitity-guide-of-git.json","excerpt":"<p>&emsp;&emsp;对于git的接触我也算较晚的，应该是到了大二会有一些团队项目，才开始使用git。也仅仅局限于简单的了解，对于很多原理都不了解，出了问题，就只有找百度。在实验室老师也只推崇svn，当时也是一个接近10人的团队提交代码。大家也都是用的GUI，记得当时三天两头就会出问题。后来因为要找实习就转到git上来了，而且大部分开源项目都发布在github等社区。后来在工作中又出过事故，觉得还是得好好了解下git。在推荐下看了git权威指南这本书。</p>\n<p>&emsp;&emsp;这本书怎么说呢？有亮点也有缺点，这是必然的。先说亮点，文章条理和章节设计非常合理，而且在前言里还推荐了不同人群的阅读重点。根据阅读重点，我基本上第一篇就是简单阅读掠过，第二篇就也粗略的过了一下，相比第一篇投入时间的更多一些，第三篇是作者推荐的重点阅读篇，花的时间较多，但是很多东西接触的不多或者甚至没有接触，所以读起来有些晦涩的感觉。结合作者的例子读起来稍好一些，然后作者讲了一些git背后的原理，对于想知其然，知其所以然还是比较好。然后缺点的话，确实有点太啰嗦了，有点影响阅读，比如花了30多页的篇幅去讲在不同操作系统下git的安装，我觉得是没那么必要的。再有就是从“权威指南”这四个字，我觉得定位不那么合理，我认为的权威指南是类似犀牛书那种的，什么操作、命令之类的忘记了，我可以查权威指南解决问题的。总之就是涵盖的东西确实很广，但是定位不够明确，针对的读者用户群较广，就感觉被捆绑消费了，感觉大多数人可能会抱着如何用好git或者了解如果搭建git、迁移到git这两方面或者更多。另外介绍cvs、svn以及其他版本控制系统，个人觉得没什么必要，要么别人是受够了svn转git对svn已经很了解了，要么是没有接触过svn想直接入门git的，所以介绍了只是徒增阅读时间罢了。</p>\n<p>&emsp;&emsp;再来说我读了之后感觉提升还是蛮大的，至少不会再像之前不知道stash，在一个分支下改了一些东西，要切到另一个分支，自己傻傻的将修改的内容全部还原再切换分支，然后又从头来过，简直被自己蠢哭。然后对git的基本操作了解的更多了，对于解决冲突、分支有了进一步的了解。提升的话可能较之前好得多，但还是有些地方理解的不深刻，对本书有了一定了解之后，感觉有些地方还需要花时间精读，另外在使用git中碰到问题回来查印象肯定也会更深刻一些。</p>\n","keywords":null,"cover":null,"content":null,"text":"&emsp;&emsp;对于git的接触我也算较晚的，应该是到了大二会有一些团队项目，才开始使用git。也仅仅局限于简单的了解，对于很多原理都不了解，出了问题，就只有找百度。在实验室老师也只推崇svn，当时也是一个接近10人的团队提交代码。大家也都是用的GUI，记得当时三天两头就","link":"","raw":null,"photos":[],"categories":[{"name":"git","slug":"git","count":1,"path":"api/categories/git.json"}],"tags":[{"name":"git","slug":"git","count":1,"path":"api/tags/git.json"},{"name":"读书笔记","slug":"读书笔记","count":1,"path":"api/tags/读书笔记.json"}]},{"title":"unity-cache-server-cache-modules","slug":"unity-cache-server-cache-modules","date":"2018-09-28T02:43:06.000Z","updated":"2018-10-02T15:01:49.428Z","comments":true,"path":"api/articles/unity-cache-server-cache-modules.json","excerpt":"<h2 id=\"Cache-Modules\"><a href=\"#Cache-Modules\" class=\"headerlink\" title=\"Cache Modules\"></a>Cache Modules</h2><p>&emsp;&emsp;Unity-cache-server v6的缓存服务器支持两种缓存机制：</p>\n<ul>\n<li>cache_fs，基于文件系统的缓存</li>\n<li>完全内存（RAM）支持的缓存</li>\n</ul>\n<p>&emsp;&emsp;cache server默认使用cache_fs即文件系统缓存模式，适用于大多数的应用程序。RAM缓存模式提供最佳性能，但Server需要足够的物理RAM用于缓存，通常需要的内存大小至少为项目Library文件夹的2-3倍。</p>\n<p>&emsp;&emsp;两个模式的配置文件信息都在config/defalult.yml中进行配置。</p>\n<h2 id=\"cache-fs\"><a href=\"#cache-fs\" class=\"headerlink\" title=\"cache_fs\"></a>cache_fs</h2><p>&emsp;&emsp;一个简单且高效的文件系统缓存模式。</p>\n<p><strong>用法</strong></p>\n<p><code>--cache-module cache_fs</code></p>\n<p><strong>命令</strong></p>","keywords":null,"cover":null,"content":null,"text":"Cache Modules&emsp;&emsp;Unity-cache-server v6的缓存服务器支持两种缓存机制：cache_fs，基于文件系统的缓存完全内存（RAM）支持的缓存&emsp;&emsp;cache server默认使用cache_fs即文件系统缓存模式，适","link":"","raw":null,"photos":[],"categories":[{"name":"unity","slug":"unity","count":2,"path":"api/categories/unity.json"}],"tags":[{"name":"cacheserver","slug":"cacheserver","count":2,"path":"api/tags/cacheserver.json"}]},{"title":"Unity-Cache-Server","slug":"unity-cache-server","date":"2018-09-26T01:38:21.000Z","updated":"2018-10-02T15:01:49.428Z","comments":true,"path":"api/articles/unity-cache-server.json","excerpt":"<p><em>注：由于没有做过游戏开发，也没有使用过unity，所以有问题的地方欢迎在评论指正</em></p>\n<h2 id=\"缓存服务器\"><a href=\"#缓存服务器\" class=\"headerlink\" title=\"缓存服务器\"></a>缓存服务器</h2><p>&emsp;&emsp;Unity的打包流程中最慢的环节就是贴图的压缩。不同的平台，需要把原始贴图压缩成对应平台的压缩贴图格式。iOS和Android平台对应的格式不同。针对这个问题，Unity官方给出了一个CacheServer的解决方案。CacheServer只是一个文件cache服务器，记录了贴图源文件和转换参数(meta文件)以及转换器版本等信息构成的字符串的md5值作为文件索引。第一个做转换的人，在本地进行压缩后，会把结果传到CacheServer，其他人使用时，就会优先去看有没有人做过同样的工作，如果有就从cache服务器下载资源，没有就会进行压缩，并上传结果到CacheServer。如果源文件、转换参数都完全一样，结果会被缓存。在日常所有贴图都会被压缩过，可以节约压缩贴图的时间，从而减少打包时间。</p>\n<p>&emsp;&emsp;Unity官方在3月发布了Cache Server v6.0.0版本，官方宣称6.0带来了更高的可靠性和性能，以及一系列的新功能。包括新模块化，实现最大的I/O性能，支持高性能的缓存模式等等。</p>\n<p>&emsp;&emsp;Unity用户手册中也有关于Cache Server介绍和使用，但截至9.26日，官网的用户手册还停留在2月份的，没有做更新。关于文件更改请仔细阅读官网手册英文原文说明或下方翻译：</p>\n<blockquote>\n<p>关于缓存服务器，Unity具有一个全自动的资源管道。当修改了类似于<code>.psd</code>或<code>.fbx</code>文件的资源后，Unity将检测到更改并自动重新导入更改后的文件。从文件导入的数据之后将由Unity按其内部格式存储。资源管道最重要的部分是“热重载”功能和保证您的所有资源始终同步为所见即所得模式。此功能的实现也是要付出代价的。任何修改的资源必须重新导入。在一个大团队中工作时，获得了最新的管理源代码(Source Control)后，您通常需要等很长一段时间才可将所有其他成员修改或创建的资源重新导入完成。另外，在PC和移动平台之间来回切换工程平台，也将引发重新导入大部分资源的操作。</p>\n<p>在<strong>缓存服务器(Cache Server)</strong>上缓存导入的资源数据可大幅缩短导入资源占用的时间。</p>\n<p>缓存每个导入的资源基于：</p>\n<p>&emsp;&emsp;<em>资源文件本身</em></p>\n<p>&emsp;&emsp;<em>导入设置</em></p>\n<p>&emsp;&emsp;<em>资源导入器版本</em></p>\n<p>&emsp;&emsp;<em>当前平台</em></p>\n<p>如果上述四项任意一项发生变化，资源将重新导入，否则，会从缓存服务器(Cache Server)下载更新后的资源。启用偏好设置(Preferences)中的缓存服务器后，您可以共享多个工程的导入资源。</p>\n<p><strong><em>注意：将缓存服务器设置好后，这个过程将是完全自动的，这意味着无需其他工作流程。它只是缩短了导入工程的时间，无需您进行操作。</em></strong></p>\n</blockquote>\n<h2 id=\"配置要求\"><a href=\"#配置要求\" class=\"headerlink\" title=\"配置要求\"></a>配置要求</h2><p>&emsp;&emsp;只考虑将CacheServer搭在本地环境，cache服务器不同于版本控制，其缓存数据可以随时在本地重建，没必要使用远程服务器。如果存在开发团队分布在各地的情况，选择在每个地方配置一台独立缓存服务器比较好。</p>\n<p>&emsp;&emsp;因为CacheServer只相当于一个文件cache服务器，所以配置并不需要太高。但是为了最佳性能，机器必须要有足够的RAM来存储整个导入的工程文件夹。机器最好使用SSD，保证读写速度。另外CacheServer的CPU使用率非常低。最好使用Linux或Mac OS X系统。Windows 文件系统未对资源缓存服务器 (Asset Cache Server) 存储数据的方式进行特别理想的优化，Windows 上的文件锁定问题可引发问题，但 Linux 或 Mac OS X 上不会出现此类问题。</p>\n<h2 id=\"用户使用\"><a href=\"#用户使用\" class=\"headerlink\" title=\"用户使用\"></a>用户使用</h2>","keywords":null,"cover":"https://i.loli.net/2018/09/26/5bab3ffe7a483.png","content":null,"text":"注：由于没有做过游戏开发，也没有使用过unity，所以有问题的地方欢迎在评论指正缓存服务器&emsp;&emsp;Unity的打包流程中最慢的环节就是贴图的压缩。不同的平台，需要把原始贴图压缩成对应平台的压缩贴图格式。iOS和Android平台对应的格式不同。针对这个问题，Uni","link":"","raw":null,"photos":[],"categories":[{"name":"unity","slug":"unity","count":2,"path":"api/categories/unity.json"}],"tags":[{"name":"cacheserver","slug":"cacheserver","count":2,"path":"api/tags/cacheserver.json"}]},{"title":"原型链与继承-JS高级","slug":"the-proptotype-chain-and-inheritance","date":"2018-09-24T04:42:15.000Z","updated":"2018-10-02T15:01:49.428Z","comments":true,"path":"api/articles/the-proptotype-chain-and-inheritance.json","excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>&emsp;&emsp;初学javascript的时候对原型链和继承就一知半解，上半年复习的时候感觉十分良好，直到最近又被问道的时候，还是讲不清楚。自己就又看了一遍JS高级程序设计，力求有更深的理解，彻底搞懂。</p>\n<p>&emsp;&emsp;继承是OO语言中的一个最为人津津乐道的概念。许多OO语言都支持两种继承方式：接口继承和 实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。由于js中方法没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而且其 实现继承主要是依靠原型链来实现的。本段摘自JS高级程序设计。</p>\n<h2 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h2><p>&emsp;&emsp;原型和实例关系：</p>\n<blockquote>\n<p>每个构造函数(constructor)都有一个原型对象(prototype)，原型对象都包含一个指向构造函数的指针，而实例(instance)都包含一个只想原型对象的内部指针。</p>\n</blockquote>\n<p>&emsp;&emsp;如果试图引用对象(instance)的某个属性，首先会在对象内部有没有这个属性，找不到时才会在该对象的原型(prototype)里去寻找这个属性。</p>\n<p>&emsp;&emsp;让一个实例的原型对象指向另一个类型的实例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">thisConstructor.prototype = otherInstance</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们如果要引用thisConstructor构造的实例thisInstance的属性name，</p>","keywords":null,"cover":null,"content":null,"text":"前言&emsp;&emsp;初学javascript的时候对原型链和继承就一知半解，上半年复习的时候感觉十分良好，直到最近又被问道的时候，还是讲不清楚。自己就又看了一遍JS高级程序设计，力求有更深的理解，彻底搞懂。&emsp;&emsp;继承是OO语言中的一个最为人津津乐道的概念","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":3,"path":"api/categories/javascript.json"}],"tags":[{"name":"原型链","slug":"原型链","count":1,"path":"api/tags/原型链.json"},{"name":"继承","slug":"继承","count":1,"path":"api/tags/继承.json"}]},{"title":"npm包开发","slug":"npmpackage","date":"2018-09-16T09:42:51.000Z","updated":"2018-10-02T15:01:49.428Z","comments":true,"path":"api/articles/npmpackage.json","excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>&emsp;&emsp;之前做项目的时候遇到了一个npm包在typescript程序中无法使用的问题，添加了@types也无法作用。打算自己学习一下npm包的开发。简单的记录一下npm包开发的过程。</p>\n<h2 id=\"必备\"><a href=\"#必备\" class=\"headerlink\" title=\"必备\"></a>必备</h2><p>&emsp;&emsp;1.注册一个npm账号，<a href=\"https://www.npmjs.com/\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/</a></p>\n<p>&emsp;&emsp;2.安装nodejs</p>\n<p>&emsp;&emsp;3.安装git</p>\n<p>&emsp;&emsp;安装过程就不贴了，都很简单，安装教程也很多。</p>\n<h2 id=\"创建npm包\"><a href=\"#创建npm包\" class=\"headerlink\" title=\"创建npm包\"></a>创建npm包</h2><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── bin           <span class=\"comment\">//命令配置</span></span><br><span class=\"line\">├── README<span class=\"selector-class\">.md</span>     <span class=\"comment\">//说明文档</span></span><br><span class=\"line\">├── index<span class=\"selector-class\">.js</span>      <span class=\"comment\">//主入口</span></span><br><span class=\"line\">├── src           <span class=\"comment\">//功能文件</span></span><br><span class=\"line\">├── package<span class=\"selector-class\">.json</span>  <span class=\"comment\">//包信息</span></span><br><span class=\"line\">└── test          <span class=\"comment\">//测试用例</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;大致的目录结构如上，我们在src下新建一个resize.js，然后写上代码：</p>","keywords":null,"cover":"https://i.loli.net/2018/09/17/5b9eed3b8bdf1.png","content":null,"text":"前言&emsp;&emsp;之前做项目的时候遇到了一个npm包在typescript程序中无法使用的问题，添加了@types也无法作用。打算自己学习一下npm包的开发。简单的记录一下npm包开发的过程。必备&emsp;&emsp;1.注册一个npm账号，https://www.n","link":"","raw":null,"photos":[],"categories":[{"name":"npm","slug":"npm","count":1,"path":"api/categories/npm.json"}],"tags":[{"name":"npm","slug":"npm","count":1,"path":"api/tags/npm.json"}]},{"title":"Vue slot(插槽)","slug":"vueslot","date":"2018-09-09T02:51:57.000Z","updated":"2018-10-02T15:01:49.429Z","comments":true,"path":"api/articles/vueslot.json","excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>&emsp;&emsp;插槽是组件的一部分，当时做项目的时候使用到了插槽，并不是很懂，vue官网也没有说明的很清楚，只是说vue实现了一套内容分发的api，\\<slot>元素承载分发内容的出口。也就是说插槽是用来分发内容的。那就举个栗子说明一下：</slot></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// app</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">component-a</span>&gt;</span></span><br><span class=\"line\">   这是插槽内容</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">component-a</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">// component-a html</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">\thello，word！</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;上面app中放了一个component-a组件，组件的内容是下面的，这样在浏览器中渲染出来的结果是什么呢？结果是只会渲染出组件中的内容。app中组件标签里的内容被抛弃了。我们在组件中加一下slot，会发现之前写在组件内的内容出来了，这就是插槽的作用，可以分发内容。意思就是如果不使用插槽，在组件标签内写的任何内容都是不会生效的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">        &lt;component-a&gt;</span><br><span class=\"line\">            这是插槽内容</span><br><span class=\"line\">         &lt;/component-a&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        Vue.component(&apos;component-a&apos;,&#123;</span><br><span class=\"line\">            template: `</span><br><span class=\"line\">            &lt;div&gt;hello,word!&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;</span><br><span class=\"line\">            `</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        const app = new Vue(&#123;</span><br><span class=\"line\">            el: &apos;#app&apos;,</span><br><span class=\"line\">            data() &#123;</span><br><span class=\"line\">                return &#123;&#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这个插槽也叫单个插槽。</p>\n<h2 id=\"具名插槽\"><a href=\"#具名插槽\" class=\"headerlink\" title=\"具名插槽\"></a>具名插槽</h2><p>&emsp;&emsp;具名插槽就是具有名字的插槽，在组件中给插槽取上名字，然后再组件标签内slot属性填上名字，它就会跟组件内的name一一对应。那么没有名字的就是默认插槽了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">        .border &#123;</span><br><span class=\"line\">            border: 1px solid #e7494b;</span><br><span class=\"line\">        &#125;s</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">        &lt;component-a&gt;</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                默认插槽的内容</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">            &lt;template slot=&quot;slota&quot;&gt;</span><br><span class=\"line\">                插槽a的内容</span><br><span class=\"line\">            &lt;/template&gt;</span><br><span class=\"line\">            &lt;template slot=&quot;slotb&quot;&gt;</span><br><span class=\"line\">                插槽b的内容</span><br><span class=\"line\">            &lt;/template&gt;</span><br><span class=\"line\">         &lt;/component-a&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        Vue.component(&apos;component-a&apos;,&#123;</span><br><span class=\"line\">            template: `</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">              &lt;h2&gt;具名插槽&lt;/h2&gt;</span><br><span class=\"line\">              &lt;slot&gt;&lt;/slot&gt;</span><br><span class=\"line\">              &lt;div class=&quot;border&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">              &lt;slot name=&quot;slota&quot;&gt;&lt;/slot&gt;</span><br><span class=\"line\">              &lt;div class=&quot;border&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">              &lt;slot name=&quot;slotb&quot;&gt;&lt;/slot&gt;</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">            `</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        const app = new Vue(&#123;</span><br><span class=\"line\">            el: &apos;#app&apos;,</span><br><span class=\"line\">            data() &#123;</span><br><span class=\"line\">                return &#123;&#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"作用域插槽\"><a href=\"#作用域插槽\" class=\"headerlink\" title=\"作用域插槽\"></a>作用域插槽</h2>","keywords":null,"cover":null,"content":null,"text":"前言&emsp;&emsp;插槽是组件的一部分，当时做项目的时候使用到了插槽，并不是很懂，vue官网也没有说明的很清楚，只是说vue实现了一套内容分发的api，\\元素承载分发内容的出口。也就是说插槽是用来分发内容的。那就举个栗子说明一下：1<br>2<br>3<br>4<br>5","link":"","raw":null,"photos":[],"categories":[{"name":"vue","slug":"vue","count":6,"path":"api/categories/vue.json"}],"tags":[{"name":"slot","slug":"slot","count":1,"path":"api/tags/slot.json"}]},{"title":"Vue数据单向流动","slug":"vue-sigleway-flow","date":"2018-09-02T05:33:00.000Z","updated":"2018-10-02T15:01:49.428Z","comments":true,"path":"api/articles/vue-sigleway-flow.json","excerpt":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><hr>\n<p>  &emsp;&emsp;官方说法叫单向数据流，意思是父级prop的更新会向下流动到子组件中，但是反过来是不行的。为的是防止子组件修改父组件的状态。但是实际开发中我们可能会遇到以下两种情况：</p>\n<p>&emsp;&emsp;1. 需要使用并修改父组件传递的数据，但不需要回传给父组件</p>\n<p>&emsp;&emsp;2. 需要使用并修改父组件传递的数据并回传给父组件</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>&emsp;&emsp;如果我们将父组件prop的数据直接在input中进行了修改，vue在控制台中给出警告，栗子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// html</span><br><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;p&gt;&#123;&#123; title &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">    &lt;conponent-son :title=&quot;title&quot;&gt;&lt;/conponent-son&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">        Vue.component(&apos;conponent-son&apos;, &#123;</span><br><span class=\"line\">            props: [&apos;title&apos;],</span><br><span class=\"line\">            template: `&lt;div&gt;</span><br><span class=\"line\">                &lt;input type=&quot;text&quot; v-model=&quot;title&quot;&gt;</span><br><span class=\"line\">            &lt;/div&gt;`</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        const app = new Vue(&#123;</span><br><span class=\"line\">            el: &apos;#app&apos;,</span><br><span class=\"line\">            data() &#123;</span><br><span class=\"line\">                return &#123;</span><br><span class=\"line\">                    title: &apos;文章&apos;,</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            mounted() &#123;</span><br><span class=\"line\">                // 模拟异步加载数据</span><br><span class=\"line\">                window.setTimeout(()=&gt;&#123;</span><br><span class=\"line\">                    this.title = &apos;文章&apos;;</span><br><span class=\"line\">                &#125;,100);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://i.loli.net/2018/09/02/5b8bb4fc4f1e6.png\" alt=\"错误\"></p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2>","keywords":null,"cover":"https://i.loli.net/2018/09/02/5b8bb4fc4f1e6.png","content":null,"text":"介绍  &emsp;&emsp;官方说法叫单向数据流，意思是父级prop的更新会向下流动到子组件中，但是反过来是不行的。为的是防止子组件修改父组件的状态。但是实际开发中我们可能会遇到以下两种情况：&emsp;&emsp;1. 需要使用并修改父组件传递的数据，但不需要回传给父组件&","link":"","raw":null,"photos":[],"categories":[{"name":"vue","slug":"vue","count":6,"path":"api/categories/vue.json"}],"tags":[{"name":"component","slug":"component","count":1,"path":"api/tags/component.json"},{"name":"单向流动","slug":"单向流动","count":1,"path":"api/tags/单向流动.json"}]},{"title":"双向绑定","slug":"vuedoublesidedbind","date":"2018-08-26T02:24:55.000Z","updated":"2018-10-02T15:01:49.429Z","comments":true,"path":"api/articles/vuedoublesidedbind.json","excerpt":"<h2 id=\"双向绑定\"><a href=\"#双向绑定\" class=\"headerlink\" title=\"双向绑定\"></a>双向绑定</h2><p>&emsp;&emsp;数据的双向绑定可以说是MVVM框架的核心思想，MVVM框架包括三个部分，Model、View和ViewModel，分别指数据、视图、ViewModel可以说是前二者的连接者，二者通过它实现数据的双向绑定。以Vue为例，先看下Vue官网数据绑定的示意图：</p>\n<p><img src=\"https://i.loli.net/2018/08/26/5b827f69c1a85.png\" alt=\"数据绑定\"></p>\n<p>&emsp;&emsp;<em>这张图想表达的是，对象a下的属性b定义了getter、setter对属性进行劫持，当属性值改变时就会notify通知watch对象，而watch对象则会notify到view更新。反之，在视图改变数据时，也会触发订阅者watch，更新数据到data中。这样的model能实时响应view上的数据变化，view实时响应model的数据变化，这样的一个过程就叫数据的双向绑定。</em></p>\n<p>&emsp;&emsp;Vue是通过ES5中Object.defineProperty()这个方法来实现getter、setter对数据进行劫持，所以要运行Vue的运行环境需支持ES5。</p>\n<h2 id=\"Object-defineProperty\"><a href=\"#Object-defineProperty\" class=\"headerlink\" title=\"Object.defineProperty()\"></a>Object.defineProperty()</h2><p>&emsp;&emsp;这是一个ES5的方法，可以在一个对象上定义一个新属性或用来修改一个已经存在的属性，并返回该对象。目前对象的属性描述符有两种主要形式：此数据描述符和存取描述符。</p>\n<p>&emsp;&emsp;<em>数据描述符是一个拥有一个可写或不可写值的属性</em></p>\n<p>&emsp;&emsp;<em>存取描述符是由一对getter-setter函数功能来描述的属性</em></p>\n<p>&emsp;&emsp;描述符只能是以上两种之一，不可能同时拥有这两种。描述符属性包括：configurable(可配置性，这又为true时才能设置)、Writable(是否可写)、Enumerable(是否可枚举)、get(给属性提供getter)、setter(给属性提供setter)。看下这个例子：</p>","keywords":null,"cover":"https://i.loli.net/2018/08/26/5b827f69c1a85.png","content":null,"text":"双向绑定&emsp;&emsp;数据的双向绑定可以说是MVVM框架的核心思想，MVVM框架包括三个部分，Model、View和ViewModel，分别指数据、视图、ViewModel可以说是前二者的连接者，二者通过它实现数据的双向绑定。以Vue为例，先看下Vue官网数据绑定的示意","link":"","raw":null,"photos":[],"categories":[{"name":"vue","slug":"vue","count":6,"path":"api/categories/vue.json"}],"tags":[{"name":"双向绑定","slug":"双向绑定","count":1,"path":"api/tags/双向绑定.json"}]},{"title":"Vuex","slug":"vuex","date":"2018-08-19T07:30:47.000Z","updated":"2018-10-02T15:01:49.429Z","comments":true,"path":"api/articles/vuex.json","excerpt":"<h2 id=\"Vuex\"><a href=\"#Vuex\" class=\"headerlink\" title=\"Vuex\"></a>Vuex</h2><p>&emsp;&emsp;官方说vuex是一个专为vue.js应用程序开发的<strong>状态管理模式</strong>。它采用<strong>集中式</strong>存储管理应用的<strong>所有组件的状态</strong>，并以相应的规则保证状态以一种可预测的方式发生变化。</p>\n<p>&emsp;&emsp;按我的理解就是，Vuex也是用来管理组建之间通信的。组件之间都是独立的，组件之间想实现通信，就要用到之前的文章提到的props选项，自定义事件，以及eventbus，前两种只适用于父子关系，eventbus可以适用所有的组件通信。但是据说不是很推荐，我想可能的原因是在大型项目中，到处引用一个eventbus代码可读性差、可能会命名冲突等，以及数据并不好进行管理。而Vuex就是解决这样的问题的，将组件需要共享的数据提出来，在一定的规则下管理这些数据，在大型项目中看起来就会仅仅有条。当然我也说了，是<strong>大型项目</strong>，一般的小项目还是用前三种方式去做吧，不要为了用vuex而用。</p>\n<h2 id=\"使用Vuex\"><a href=\"#使用Vuex\" class=\"headerlink\" title=\"使用Vuex\"></a>使用Vuex</h2><p>&emsp;&emsp;先创建一个实例，了解一下vuex：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"X-UA-Compatible\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"ie=edge\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>vuex<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdn.bootcss.com/vue/2.5.17-beta.0/vue.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdn.bootcss.com/vuex/3.0.1/vuex.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">    Vue.use(Vuex);</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"comment\">// 存放组件之间共享的数据</span></span></span><br><span class=\"line\"><span class=\"undefined\">        state: &#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">            name: <span class=\"string\">'myName'</span></span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;,</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"comment\">// 显示更改state里的数据</span></span></span><br><span class=\"line\"><span class=\"undefined\">        mutations: &#123;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;,</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"comment\">// 获取数据的方法</span></span></span><br><span class=\"line\"><span class=\"undefined\">        getters: &#123;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;,</span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"comment\">// 类似mutation，不是直接变更状态，而是提交mutation，还可以包含异步操作</span></span></span><br><span class=\"line\"><span class=\"undefined\">        actions: &#123;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;);</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"keyword\">new</span> Vue (&#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">        el: <span class=\"string\">'#app'</span>,</span></span><br><span class=\"line\"><span class=\"undefined\">        data() &#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">            <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">                name: <span class=\"string\">'null'</span></span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;,</span></span><br><span class=\"line\"><span class=\"undefined\">        store,</span></span><br><span class=\"line\"><span class=\"undefined\">        mounted() &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.$store);</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125; </span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;在创建vue实例前需使用vuex，也就是Vue.use(Vuex)，使用Vuex.Store({})方法创建一个仓库，当Vue组件从store中读取state选项也就是状态，如果store中状态发生更新时，它会及时响应将数据发给其它组件，如果要直接改变store的状态，就使用使用mutations进行显式的更改。另外四个核心选项在代码中已经注释说明了。我们在控制台中打印了$store，来看看有哪些东西：</p>\n<p><img src=\"https://i.loli.net/2018/08/19/5b797da78e02d.png\" alt=\"store\"></p>\n<p>&emsp;&emsp;一般情况下会在组件的计算属性中来获取state的数据，原因是计算属性会监控数据变化，数据改变就会响应。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在上面代码的html中加一个helloword的标签，在注册一个helloword的组件。就可以到浏览器中看到效果了。</span></span><br><span class=\"line\">Vue.component(<span class=\"string\">'helloword'</span>,&#123;</span><br><span class=\"line\">        template:<span class=\"string\">\"&lt;div&gt;&#123;&#123; name &#125;&#125;&lt;/div&gt;\"</span>,</span><br><span class=\"line\">        computed: &#123;</span><br><span class=\"line\">            name() &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.state.name</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">         mounted() &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>","keywords":null,"cover":"https://i.loli.net/2018/08/19/5b797da78e02d.png","content":null,"text":"Vuex&emsp;&emsp;官方说vuex是一个专为vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。&emsp;&emsp;按我的理解就是，Vuex也是用来管理组建之间通信的。组件之间都是独立","link":"","raw":null,"photos":[],"categories":[{"name":"vue","slug":"vue","count":6,"path":"api/categories/vue.json"}],"tags":[{"name":"通信","slug":"通信","count":2,"path":"api/tags/通信.json"},{"name":"vuex","slug":"vuex","count":1,"path":"api/tags/vuex.json"}]}]}