{"total":16,"pageSize":10,"pageCount":2,"data":[{"title":"Vue组件之间通信","slug":"vueconponentscommunity","date":"2018-08-05T09:56:29.000Z","updated":"2018-10-02T15:01:49.429Z","comments":true,"path":"api/articles/vueconponentscommunity.json","excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>&emsp;&emsp;之前在学校一直在用nodom框架进行开发，对vue的了解也仅仅局限于对比二者的区别，并没有很深入的去了解。而且nodom的用法和vue的比较相似，所以上手vue是比较快的，但是其中很多原理并不熟悉，所以想总结并分享一下学到的东西。  </p>\n<p>&emsp;&emsp;组件化是vue.js或者说现在的mvvm框架中一个重要的思想，也是前端发展的趋势，这其中组件间的通信又是vue数据驱动的灵魂所在。所以在这谈谈Vue2.x的组件通信，这一篇主要聊聊非Vuex的做法，下一篇文章再讲Vuex。Vue2.x已经废弃了$dispatch和$broadcast，nodom中还保留着broadcast的方法…  </p>\n<h3 id=\"父子组件通信\"><a href=\"#父子组件通信\" class=\"headerlink\" title=\"父子组件通信\"></a>父子组件通信</h3><h4 id=\"1-父子组件，父组件向子组件传递数据\"><a href=\"#1-父子组件，父组件向子组件传递数据\" class=\"headerlink\" title=\"1.父子组件，父组件向子组件传递数据\"></a>1.父子组件，父组件向子组件传递数据</h4><p>&emsp;&emsp;父组件向子组件传递数据时，这是比较简单也是比较常见的一种方式，我们首先看看props，prop的值有两种一种是使用数组和对象，静态数据比较简单，作为理解就使用数组为例了，先看下代码：  </p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"\"</span>&gt;</span></span><br><span class=\"line\">      父组件</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">child</span> <span class=\"attr\">message</span>=<span class=\"string\">\"父亲给儿子说的话：xxxxx\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">child</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"actionscript\">    Vue.component(<span class=\"string\">'child'</span>,&#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">      props: [<span class=\"string\">'message'</span>],</span></span><br><span class=\"line\"><span class=\"handlebars\"><span class=\"xml\">      template: '<span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123; &#123; message &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>'</span></span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;);</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Vue(&#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">      el: <span class=\"string\">'#app'</span></span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\">  </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;通过在props中声明数据，在子组件中添加message并赋值进行传递，需要注意的是HTML不区分大小写，在dom模板中，驼峰命名的props名称要转为短横线分隔命名。  </p>\n<p>&emsp;&emsp;另外在实际开发中，很少会传递死的数据，大部分都是使用动态数据，此时我们需要使用v-bind指令来绑定父组件数据，当父组件数据发生变化时，也会传递给子组件，代码：  </p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"\"</span>&gt;</span></span><br><span class=\"line\">      父组件数据</span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"parentMessage\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    child :message=\"parentMessage\"<span class=\"tag\">&lt;/<span class=\"name\">child</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"actionscript\">    Vue.component(<span class=\"string\">'child'</span>,&#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">      props: [<span class=\"string\">'message'</span>],</span></span><br><span class=\"line\"><span class=\"handlebars\"><span class=\"xml\">      template: '<span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>子组件收到的消息：&#123; &#123; message &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>'</span></span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;);</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Vue(&#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">      el: <span class=\"string\">'#app'</span>,</span></span><br><span class=\"line\"><span class=\"undefined\">      data: &#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">        parentMessage: <span class=\"string\">''</span></span></span><br><span class=\"line\"><span class=\"undefined\">      &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\">  </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>","keywords":null,"cover":null,"content":null,"text":"前言&emsp;&emsp;之前在学校一直在用nodom框架进行开发，对vue的了解也仅仅局限于对比二者的区别，并没有很深入的去了解。而且nodom的用法和vue的比较相似，所以上手vue是比较快的，但是其中很多原理并不熟悉，所以想总结并分享一下学到的东西。  &emsp;&em","link":"","raw":null,"photos":[],"categories":[{"name":"vue","slug":"vue","count":6,"path":"api/categories/vue.json"}],"tags":[{"name":"VUE","slug":"VUE","count":1,"path":"api/tags/VUE.json"},{"name":"组件","slug":"组件","count":1,"path":"api/tags/组件.json"},{"name":"通信","slug":"通信","count":2,"path":"api/tags/通信.json"}]},{"title":"Vue实例生命周期","slug":"vuelifecyle","date":"2018-07-06T16:56:17.000Z","updated":"2018-10-02T15:01:49.429Z","comments":true,"path":"api/articles/vuelifecyle.json","excerpt":"<h2 id=\"Vue实例生命周期\"><a href=\"#Vue实例生命周期\" class=\"headerlink\" title=\"Vue实例生命周期\"></a>Vue实例生命周期</h2><p>&emsp;&emsp;先来上一张vue官网的生命周期图：  </p>\n<p><img src=\"https://i.loli.net/2018/09/08/5b9380089a9dc.png\" alt=\"生命周期\"></p>\n<p>一个vue实例在创建的时候会调用上面的钩子函数，vue的生命周期钩子函数有：  </p>\n<ul>\n<li><p>beforeCreate</p>\n</li>\n<li><p>created</p>\n</li>\n<li><p>beforeMount</p>\n</li>\n<li><p>mounted</p>\n</li>\n<li><p>beforeUpdate</p>\n</li>\n<li><p>updated</p>\n</li>\n<li><p>beforeDestroy</p>\n</li>\n<li><p>destroyed</p>\n</li>\n</ul>\n<p>&emsp;&emsp;下面来一一讲解vue的生命周期钩子函数：  </p>\n<p><strong>beforeCreate：</strong></p>\n<p>&emsp;&emsp;vue实例创建前，el、data、methods都还未生成。  </p>\n<p><strong>created：</strong></p>\n<p>&emsp;&emsp;vue实例创建完成，这一阶段进行<strong>事件初始化，同时观测数据</strong>。注意：此时el还是读不到。  </p>","keywords":null,"cover":"https://i.loli.net/2018/09/08/5b9380089a9dc.png","content":null,"text":"Vue实例生命周期&emsp;&emsp;先来上一张vue官网的生命周期图：   [Figure] 一个vue实例在创建的时候会调用上面的钩子函数，vue的生命周期钩子函数有：  beforeCreatecreatedbeforeMountmountedbeforeUpdateu","link":"","raw":null,"photos":[],"categories":[{"name":"vue","slug":"vue","count":6,"path":"api/categories/vue.json"}],"tags":[{"name":"生命周期","slug":"生命周期","count":1,"path":"api/tags/生命周期.json"}]},{"title":"JavaScript-单例模式","slug":"javascriptsingleton","date":"2018-07-06T16:19:04.000Z","updated":"2018-10-02T15:01:49.428Z","comments":true,"path":"api/articles/javascriptsingleton.json","excerpt":"<p>JavaScript单例模式  </p>\n<hr>\n<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><p>&emsp;&emsp;单例模式时一种较为简单的设计模式，传统的单例模式是指保证一个类只有一个实例，并提供一个访问它的全局访问点。  </p>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>&emsp;&emsp;实现的思路是定义一个变量标志是否已经创建过实例，如果已经有实例，则返回该实例对象，否则创建一个实例并返回。用一个创建登录框的例子来说明单例模式在JavaScript中如何实现：  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> loginHtml = <span class=\"string\">\"账号：&lt;input type=\\\"text\\\" /&gt;&lt;br/&gt;密码：&lt;input type=\\\"password\\\" /&gt;\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> createLoginDiv = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">html</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.html = html;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.init();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">createLoginDiv.prototype.init = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> div = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'div'</span>);</span><br><span class=\"line\">  div.innerHTML = <span class=\"keyword\">this</span>.html;</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.body.appendChild(div);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">createLoginDiv.getInstance = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> instance = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">html</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">new</span> createLoginDiv(html);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"><span class=\"keyword\">var</span> div1 = createLoginDiv.getInstance(loginHtml);</span><br><span class=\"line\"><span class=\"keyword\">var</span> div2 = createLoginDiv.getInstance(<span class=\"string\">\"账号密码\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(div1 === div2); <span class=\"comment\">// true 并且页面只有一个登录框，为第一次创建的。</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这样实现的单例模式耦合度较低，init只负责创建登录框对象，对于返回现有对象还是创建新对象交给getInstance去做，代码也很清晰。通过这样的方式我们想要在页面上只想要一个登录框时可以得到保证，只有一个登录框，不会重复创建，节约性能。</p>\n<h3 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h3><h3 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3>","keywords":null,"cover":null,"content":null,"text":"JavaScript单例模式  单例模式&emsp;&emsp;单例模式时一种较为简单的设计模式，传统的单例模式是指保证一个类只有一个实例，并提供一个访问它的全局访问点。  实现&emsp;&emsp;实现的思路是定义一个变量标志是否已经创建过实例，如果已经有实例，则返回该实例对","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":3,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":1,"path":"api/tags/javascript.json"},{"name":"singleton","slug":"singleton","count":1,"path":"api/tags/singleton.json"}]},{"title":"【转载】深入理解JavaScript事件循环(Eventloop)和microtask","slug":"eventloop","date":"2018-05-27T06:10:37.000Z","updated":"2018-10-02T15:01:49.427Z","comments":true,"path":"api/articles/eventloop.json","excerpt":"<p><strong>在做javascript练习题或者面试的时候，总会遇到下面这样的题目：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"1\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"2\"</span>);</span><br><span class=\"line\">  &#125;,<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"3\"</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"4\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 控制台输出1 4 3 2</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;想知道为什么是这样的结果，就必须理解javascript的eventloop机制，推荐这位博主DongXu的两篇文章，这里就不转载全文了，推荐大家去他的博客看，还有生动的demo，很容易懂。</p>\n<blockquote>\n<p><a href=\"http://www.cnblogs.com/dong-xu/p/7000163.html\" target=\"_blank\" rel=\"noopener\">深入理解 JavaScript 事件循环（一）— event loop</a> </p>\n<p><a href=\"http://www.cnblogs.com/dong-xu/p/7000139.html\" target=\"_blank\" rel=\"noopener\">[译]深入理解 JavaScript 事件循环（二）— task and microtask</a></p>\n</blockquote>\n","keywords":null,"cover":null,"content":null,"text":"在做javascript练习题或者面试的时候，总会遇到下面这样的题目：1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br> console.log(\"1\");<br><br>  setTimeo","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":3,"path":"api/categories/javascript.json"}],"tags":[{"name":"eventloop","slug":"eventloop","count":1,"path":"api/tags/eventloop.json"},{"name":"事件循环","slug":"事件循环","count":1,"path":"api/tags/事件循环.json"}]},{"title":"HTML语义化&HTML5","slug":"htmlyuyihua","date":"2018-05-10T13:05:59.000Z","updated":"2018-10-02T15:01:49.427Z","comments":true,"path":"api/articles/htmlyuyihua.json","excerpt":"<h2 id=\"1、什么是HTML语义化？\"><a href=\"#1、什么是HTML语义化？\" class=\"headerlink\" title=\"1、什么是HTML语义化？\"></a>1、什么是HTML语义化？</h2><p>&emsp;&emsp;就我自己理解来说，HTML是超文本标记语言。语义化就是让我们清楚整个页面的结构，不论是从代码还是文本内容，不仅要我们人清楚，也要让机器清楚。纯HTML不带样式的时候，我们也能通过代码知道标签标记的是什么内容。比如H标签，我们知道这是一个标题，p一个段落，table表格，form表单等等。HTML5更加注重语义化，新增了很多语义化的标签，如header、nav、footer、article等。关于语义化一些更多的内容可以看这个<a href=\"https://www.zhihu.com/question/20455165\" title=\"如何理解 Web 语义化？\" target=\"_blank\" rel=\"noopener\">如何理解 Web 语义化？</a></p>\n<h2 id=\"2、为什么要语义化？\"><a href=\"#2、为什么要语义化？\" class=\"headerlink\" title=\"2、为什么要语义化？\"></a>2、为什么要语义化？</h2><p>&emsp;&emsp;在此之前，我写代码也基本上是全篇用div+css实现整个页面结构的，既然我们使用div+css就可以了，为什么还要使用语义化呢？  </p>\n<p>&emsp;&emsp;从实现的效果上看，使用语义化的代码和div+css的代码并没有区别，但是代码不仅是给人看的，机器也要看。从维护上面来说，语义化标签比满篇div更好维护，在页面出问题时，语义化会更加的友好。  </p>\n<p>&emsp;&emsp;语义化的好处在于建立起好的HTML结构，使搜索引擎更容易建立索引、抓取。另外就是结构清晰，便于开发人员维护。（大厂的做法，比如阿里的淘宝在div+css实现之余，也会用一些语义化的标签进行强调）  </p>\n<h2 id=\"3、语义化代码应该注意些什么？\"><a href=\"#3、语义化代码应该注意些什么？\" class=\"headerlink\" title=\"3、语义化代码应该注意些什么？\"></a>3、语义化代码应该注意些什么？</h2><ul>\n<li><p>尽可能少的使用无语义的标签div和span；在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利；</p>\n</li>\n<li><p>不要使用纯样式标签，如：b、font、u等，改用css设置。需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）；</p>\n</li>\n<li><p>使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td；</p>\n</li>\n<li><p>表单域要用fieldset标签包起来，并用legend标签说明表单的用途；每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来。</p>\n</li>\n</ul>\n<h2 id=\"4、常用的一些HTML语义标签\"><a href=\"#4、常用的一些HTML语义标签\" class=\"headerlink\" title=\"4、常用的一些HTML语义标签\"></a>4、常用的一些HTML语义标签</h2><ul>\n<li><p><code>&lt;h1&gt;</code>~<code>&lt;h6&gt;</code> ，作为标题使用，并且依据重要性递减，<code>&lt;h1&gt;</code> 是最高的等级。</p>\n</li>\n<li><p><code>&lt;p&gt;</code>段落标记，知道了 <code>&lt;p&gt;</code> 作为段落，你就不会再使用 <code>&lt;br /&gt;</code> 来换行了，而且不需要 <code>&lt;br /&gt;</code> 来区分段落与段落。<code>&lt;p&gt;</code> 中的文字会自动换行，而且换行的效果优于 <code>&lt;br /&gt;</code>。段落与段落之间的空隙也可以利用 CSS 来控制，很容易而且清晰的区分出段落与段落。</p>\n</li>\n<li><p><code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;li&gt;</code>，<code>&lt;ul&gt;</code> 无序列表，这个被大家广泛的使用，<code>&lt;ol&gt;</code> 有序列表不常用。在 Web 标准化过程中，<code>&lt;ul&gt;</code> 还被更多的用于导航条，本来导航条就是个列表，这样做是完全正确的，而且当你的浏览器不支持 CSS 的时候，导航链接仍然很好使，只是美观方面差了一点而已。</p>\n</li>\n<li><p><code>&lt;dl&gt;</code>、<code>&lt;dt&gt;</code>、<code>&lt;dd&gt;</code>，<code>&lt;dl&gt;</code> 就是“定义列表”。比如说词典里面的词的解释、定义就可以用这种列表。dl不单独使用，它通常与dt和dd一起使用。dl开启一个定义列表，dt表示要定义的项目名称，dd表示对dt的项目的描述。</p>\n</li>\n<li><p><code>&lt;em&gt;</code>、<code>&lt;strong&gt;</code>，<code>&lt;em&gt;</code> 是用作强调，<code>&lt;strong&gt;</code> 是用作重点强调。</p>\n</li>\n<li><p><code>&lt;table&gt;</code>、<code>&lt;thead&gt;</code>、<code>&lt;tbody&gt;</code>、<code>&lt;td&gt;</code>、<code>&lt;th&gt;</code>、<code>&lt;caption&gt;</code>， 就是用来做表格不要用来布局</p>\n</li>\n</ul>","keywords":null,"cover":null,"content":null,"text":"1、什么是HTML语义化？&emsp;&emsp;就我自己理解来说，HTML是超文本标记语言。语义化就是让我们清楚整个页面的结构，不论是从代码还是文本内容，不仅要我们人清楚，也要让机器清楚。纯HTML不带样式的时候，我们也能通过代码知道标签标记的是什么内容。比如H标签，我们知道这","link":"","raw":null,"photos":[],"categories":[{"name":"HTML/CSS","slug":"HTML-CSS","count":2,"path":"api/categories/HTML-CSS.json"}],"tags":[]},{"title":"【CSS】css居中方案","slug":"csscenter","date":"2018-05-07T14:54:57.000Z","updated":"2018-10-02T15:01:49.427Z","comments":true,"path":"api/articles/csscenter.json","excerpt":"<p>&emsp;&emsp;先说一下水平居中和垂直居中的一般方案.</p>\n<p>&emsp;&emsp;水平居中设置：</p>\n<blockquote>\n<ol>\n<li><p>行内元素：给父元素设置text-align:center;</p>\n</li>\n<li><p>定宽块状元素：设置左右margin值为auto</p>\n</li>\n<li><p>不定宽块状元素：</p>\n<ol>\n<li><p>在元素外加入table标签(包括table、tbody、tr、td)，在把该元素写在td内，然后设置margin的值为auto，注意是设置table不是该元素。</p>\n</li>\n<li><p>给该元素设置display:inline方法，居中方法和行内一致。</p>\n</li>\n<li><p>父元素设置float:left;position:relative和left:50%，子元素设置position:relative和left:-50%。</p>\n</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n<p>&emsp;&emsp;垂直居中设置：</p>\n<blockquote>\n<ol>\n<li><p>父元素高度确定的单行文本：设置height = line-height;</p>\n</li>\n<li><p>父元素高度确定的多行文本：</p>\n<ol>\n<li><p>插入table(和水平居中一致)，设置vertical-align:middle;</p>\n</li>\n<li><p>先设置display:table-cell，在设置vertical-align: middle;  </p>\n</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n<p>&emsp;&emsp;下面就提供几种居中的方法：</p>\n<h4 id=\"1-使用定位：position-absolute-设置left、top、margin-left、margin-top属性。\"><a href=\"#1-使用定位：position-absolute-设置left、top、margin-left、margin-top属性。\" class=\"headerlink\" title=\"1.使用定位：position:absolute;设置left、top、margin-left、margin-top属性。\"></a>1.使用定位：position:absolute;设置left、top、margin-left、margin-top属性。</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.content</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-top</span>: -<span class=\"number\">50px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: -<span class=\"number\">50px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这种方法好处是浏览器基本都能兼容，不足的地方就是需要我们固定宽高。</p>\n<h4 id=\"2-使用position-absolute-设置top、bottom、right、left为0，margin-auto\"><a href=\"#2-使用position-absolute-设置top、bottom、right、left为0，margin-auto\" class=\"headerlink\" title=\"2.使用position: absolute;设置top、bottom、right、left为0，margin:auto;\"></a>2.使用position: absolute;设置top、bottom、right、left为0，margin:auto;</h4>","keywords":null,"cover":null,"content":null,"text":"&emsp;&emsp;先说一下水平居中和垂直居中的一般方案.&emsp;&emsp;水平居中设置：行内元素：给父元素设置text-align:center;定宽块状元素：设置左右margin值为auto不定宽块状元素：在元素外加入table标签(包括table、tbody、tr","link":"","raw":null,"photos":[],"categories":[{"name":"HTML/CSS","slug":"HTML-CSS","count":2,"path":"api/categories/HTML-CSS.json"}],"tags":[{"name":"css","slug":"css","count":1,"path":"api/tags/css.json"},{"name":"居中","slug":"居中","count":1,"path":"api/tags/居中.json"}]}]}