{"total":25,"pageSize":10,"pageCount":3,"data":[{"title":"前端模块化","slug":"front-end-modular","date":"2018-11-25T02:40:40.000Z","updated":"2018-11-25T14:25:21.265Z","comments":true,"path":"api/articles/front-end-modular.json","excerpt":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>&emsp;&emsp;模块化是前端开发的一个重要理念/思想，随着web的发展，嵌入网页的代码js代码越来越来，web开发变得越来越复杂，大型的web应用的复杂程度可能超过了桌面程序，所以模块化的思想因此而发展起来。模块就是实现特定功能的相互独立的一组方法。有了模块，就可以更好的管理web应用的逻辑，使用这种方式在不仅能提高代码复用率、可维护性，还能作为开源项目提供给开发者使用。</p>\n<p>&emsp;&emsp;模块化的发展经历了几个阶段，现在逐渐发展成熟，特别是ES6的模块化，引用前端圈的话可以说是王者归来。有了模块，为了开发者能够方便的加载模块，就需要一套编写模块的规范了，比较流行的有CommonJS、AMD、以及ES6模块化规范。我觉得学习的重点主要还是ES6模块化规范，毕竟被誉为终极解决方案、王者归来等等。目前nodejs还在使用CommonJS，但相信不久的将来nodejs也会转而使用ES6模块化规范。</p>\n<h4 id=\"CommonJS\"><a href=\"#CommonJS\" class=\"headerlink\" title=\"CommonJS\"></a>CommonJS</h4><p>&emsp;&emsp;CommonJS核心思想是通过<code>require</code>方法<strong>同步</strong>加载依赖的其他模块，通过<code>module.exports</code>导出需要暴露的接口和变量。如上面所说，CommonJS的流行是因为nodejs采用了这种方式，CommonJS也被用于web开发中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 采用ES5语法</span></span><br><span class=\"line\"><span class=\"comment\">// 定义一个math模块</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> baseCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 暴露需要导出的接口和变量</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">\tadd: add,</span><br><span class=\"line\">    baseCount: baseCount</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 引入自定义模块</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> math = <span class=\"built_in\">require</span>(<span class=\"string\">'./math'</span>)</span><br><span class=\"line\"><span class=\"comment\">// 引入核心模块不需要带路径</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>)</span><br></pre></td></tr></table></figure>\n<p>优点：</p>\n<p>&emsp;&emsp;代码可复用于nodejs环境下，通过npm发布的第三方模块大多都采用CommonJS规范(现在更多的则是ES6模块规范)</p>\n<p>缺点：</p>\n<p>&emsp;&emsp;采用同步加载模块的方式，在服务端很适用，因为模块文件都存在本地，加载快。浏览器就会受限于网络原因，更好的方式是使用异步加载。</p>","keywords":null,"cover":null,"content":null,"text":"前言&emsp;&emsp;模块化是前端开发的一个重要理念/思想，随着web的发展，嵌入网页的代码js代码越来越来，web开发变得越来越复杂，大型的web应用的复杂程度可能超过了桌面程序，所以模块化的思想因此而发展起来。模块就是实现特定功能的相互独立的一组方法。有了模块，就可以更","link":"","raw":null,"photos":[],"categories":[{"name":"模块化","slug":"模块化","count":1,"path":"api/categories/模块化.json"}],"tags":[{"name":"模块化","slug":"模块化","count":1,"path":"api/tags/模块化.json"}]},{"title":"node.js+express搭建简单的web服务器","slug":"node-express-http-server","date":"2018-11-11T12:00:44.000Z","updated":"2018-11-12T00:26:40.524Z","comments":true,"path":"api/articles/node-express-http-server.json","excerpt":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>&emsp;&emsp;有朋友问我关于nodejs搭建web服务器的问题，我对node的了解也不多，所以简单的学习了解一下，帮朋友解决了一些问题。</p>\n<p>&emsp;&emsp;首先，很多人都在问nodejs适不适合web服务器开发。这个问题知乎上面已经有很多解答了，比较详细点赞较多的一条：<a href=\"https://www.zhihu.com/question/19653241/answer/15993549\" target=\"_blank\" rel=\"noopener\">使用 Node.js 的优势和劣势都有哪些？ - FengqiAsia的回答 - 知乎</a>，年代久远不知道是否适用。看了相关的介绍之后，我觉得nodejs是非常适合做web服务器的，网上大多的评价都是可靠性低，单进程、单线程，一个崩掉整个进程就崩掉之类的，异常难以定位。还有可能是从传统语言转过来写js的话，可能在一段时间内很难适应吧。</p>\n<p>&emsp;&emsp;看了下，linkedin、yahoo的服务器就是用node写的，还有之前去了解的unity-cache-server，说明node的优点是毋庸置疑的。可靠性低进程崩掉等缺点其实是都可以通过代码的健壮性来避免的(说着轻巧)，另外异常处理相关的也有很多库和进程管理程序监控node的运行。</p>\n<blockquote>\n<p>作者：尤雨溪</p>\n<p>链接：<a href=\"https://www.zhihu.com/question/20069184/answer/14385915\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/20069184/answer/14385915</a></p>\n<p>来源：知乎</p>\n<p>异步的思维是js的特点，也是node高并发性能优势的原因之一，你从传统的同步语言过来可能不习惯，但是像我们这种从前端写js过来的人就自然得像说话一样，关键还是适应。熟悉之后可以用async，Promise系 (q, bluebird) 或者 eventproxy 之类的库来改善代码嵌套的问题。</p>\n<p>异常的问题 - Node 核心库的 API 抛异常大致有三种常见情况：<br>\\1. 异步回调。按惯例，接收的回调函数第一个参数都是可能出现的异常，没有特殊情况的话你应该把异常按照同样的参数位置一层层传下去，直到最顶层的回调里进行统一处理。<br>\\2. 同步版本的api会直接抛异常。所以如果确实无法避免抛错的可能，直接 try catch，要么就避免用同步版本。<br>\\3. Stream形态的API，必须在stream对象上添加 error 的侦听函数，不然异常会直接抛出。</p>\n<p>如果出现导致进程中断的异常，说明你的代码有逻辑层面的问题（以上几点没有完全做好），你应该在开发的时候发现并处理这些异常，而不是让它们在部署环境中发生。</p>\n<p>如果你实在避免不了问题发生，你可以用 Node 的 Domain API 来对整块代码的异常进行捕捉。<br>另外可以用进程管理工具比如 forever, pm2 或是 monit 监视应用进程，崩溃后自动重启。</p>\n<p>最后回到你的问题，node是否适合做web开发 - node的独特优势是高并发，高实时性，或者单页富前端的web应用，比如实时聊天，游戏，另外node也是写JSON API的最好选择。</p>\n</blockquote>\n<p>&emsp;&emsp;另外看到了一条关于node的应用场景的回答，比较赞同，找不到链接了。大概是说node的适合 io 密集型的应用，能发挥出很好的性能，而 cpu 密集型的应用可能性能就不是最佳选择。估计这就是unity官方选择nodejs来写cacheserver的原因吧。</p>\n<h4 id=\"一个简单的web服务器\"><a href=\"#一个简单的web服务器\" class=\"headerlink\" title=\"一个简单的web服务器\"></a>一个简单的web服务器</h4><p>&emsp;&emsp;这里用了nodejs的第三方库express，express也有自己的脚手架。新建一个文件夹<code>http-server</code>，cd到该目录下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch app.js # 新建app.js文件</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 然后一顿回车，使用默认就ok，不过author可以填上自己的名字。</span></span><br><span class=\"line\">package name: (http-server)</span><br><span class=\"line\">version: (1.0.0)</span><br><span class=\"line\">description:</span><br><span class=\"line\">entry point: (app.js)</span><br><span class=\"line\">test command:</span><br><span class=\"line\">git repository:</span><br><span class=\"line\">keywords:</span><br><span class=\"line\">author: wangx</span><br><span class=\"line\">license: (ISC)</span><br><span class=\"line\">About to write to /Users/wangx/work/nodejs/http-server/package.json:</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  \"name\": \"http-server\",</span><br><span class=\"line\">  \"version\": \"1.0.0\",</span><br><span class=\"line\">  \"description\": \"\",</span><br><span class=\"line\">  \"main\": \"app.js\",</span><br><span class=\"line\">  \"scripts\": &#123;</span><br><span class=\"line\">    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  \"author\": \"wangx\",</span><br><span class=\"line\">  \"license\": \"ISC\"</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 初始化</span></span><br><span class=\"line\">npm init</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 安装express</span></span><br><span class=\"line\">npm install express --save</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;然后就可以在app.js写相关逻辑：</p>","keywords":null,"cover":null,"content":null,"text":"前言&emsp;&emsp;有朋友问我关于nodejs搭建web服务器的问题，我对node的了解也不多，所以简单的学习了解一下，帮朋友解决了一些问题。&emsp;&emsp;首先，很多人都在问nodejs适不适合web服务器开发。这个问题知乎上面已经有很多解答了，比较详细点赞较多","link":"","raw":null,"photos":[],"categories":[{"name":"nodejs","slug":"nodejs","count":1,"path":"api/categories/nodejs.json"}],"tags":[{"name":"nodejs","slug":"nodejs","count":1,"path":"api/tags/nodejs.json"},{"name":"express","slug":"express","count":1,"path":"api/tags/express.json"},{"name":"http_server","slug":"http-server","count":1,"path":"api/tags/http-server.json"}]},{"title":"快速生成项目结构图-tree命令的使用","slug":"generate-project-structure-diagram","date":"2018-11-11T03:23:25.000Z","updated":"2018-11-11T14:47:08.742Z","comments":true,"path":"api/articles/generate-project-structure-diagram.json","excerpt":"<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── app.js               # 入口文件</span><br><span class=\"line\">├── bin\t\t\t\t\t # 可执行文件</span><br><span class=\"line\">│   └── www</span><br><span class=\"line\">├── package-lock.json</span><br><span class=\"line\">├── package.json         # 项目信息及模块依赖</span><br><span class=\"line\">├── public\t\t\t\t # 存放image、css、js等静态资源</span><br><span class=\"line\">│   ├── images</span><br><span class=\"line\">│   ├── javascripts</span><br><span class=\"line\">│   └── stylesheets</span><br><span class=\"line\">│       └── style.css</span><br><span class=\"line\">├── routes\t\t\t\t # 路由文件</span><br><span class=\"line\">│   ├── index.js</span><br><span class=\"line\">│   └── users.js</span><br><span class=\"line\">└── views\t\t\t\t # 视图/模版文件</span><br><span class=\"line\">    ├── error.ejs</span><br><span class=\"line\">    └── index.ejs</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;上面这种树形项目结构图在前端项目介绍中非常常见，之前都以为是通过生成器生成或是手敲的，今天才发现linux下使用tree命令就可以直接生成上面的项目结构图。mark一下。</p>\n<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><p>&emsp;&emsp;这里就介绍mac的安装方法，通过homebrew安装就可以了。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install tree</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 安装完成之后查看安装成功与否</span></span><br><span class=\"line\">tree --version</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> tree v1.7.0 (c) 1996 - 2014 by Steve Baker, Thomas Moore, Francesc Rocher, Florian Sesser, Kyosuke Tokoro</span></span><br><span class=\"line\">tree --help # 查看帮助</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">usage: tree [-acdfghilnpqrstuvxACDFJQNSUX] [-H baseHREF] [-T title ]</span><br><span class=\"line\">\t[-L level [-R]] [-P pattern] [-I pattern] [-o filename] [--version]</span><br><span class=\"line\">\t[--help] [--inodes] [--device] [--noreport] [--nolinks] [--dirsfirst]</span><br><span class=\"line\">\t[--charset charset] [--filelimit[=]#] [--si] [--timefmt[=]&lt;f&gt;]</span><br><span class=\"line\">\t[--sort[=]&lt;name&gt;] [--matchdirs] [--ignore-case] [--] [&lt;directory list&gt;]</span><br><span class=\"line\">  ------- Listing options -------</span><br><span class=\"line\">  -a            All files are listed.</span><br><span class=\"line\">  -d            List directories only.</span><br><span class=\"line\">  -l            Follow symbolic links like directories.</span><br><span class=\"line\">  -f            Print the full path prefix for each file.</span><br><span class=\"line\">  -x            Stay on current filesystem only.</span><br><span class=\"line\">  -L level      Descend only level directories deep.</span><br><span class=\"line\">  -R            Rerun tree when max dir level reached.</span><br><span class=\"line\">  -P pattern    List only those files that match the pattern given.</span><br><span class=\"line\">  -I pattern    Do not list files that match the given pattern.</span><br><span class=\"line\">  --ignore-case Ignore case when pattern matching.</span><br><span class=\"line\">  --matchdirs   Include directory names in -P pattern matching.</span><br><span class=\"line\">  --noreport    Turn off file/directory count at end of tree listing.</span><br><span class=\"line\">  --charset X   Use charset X for terminal/HTML and indentation line output.</span><br><span class=\"line\">  --filelimit # Do not descend dirs with more than # files in them.</span><br><span class=\"line\">  --timefmt &lt;f&gt; Print and format time according to the format &lt;f&gt;.</span><br><span class=\"line\">  -o filename   Output to file instead of stdout.</span><br><span class=\"line\">  -------- File options ---------</span><br><span class=\"line\">  -q            Print non-printable characters as '?'.</span><br><span class=\"line\">  -N            Print non-printable characters as is.</span><br><span class=\"line\">  -Q            Quote filenames with double quotes.</span><br><span class=\"line\">  -p            Print the protections for each file.</span><br><span class=\"line\">  -u            Displays file owner or UID number.</span><br><span class=\"line\">  -g            Displays file group owner or GID number.</span><br><span class=\"line\">  -s            Print the size in bytes of each file.</span><br><span class=\"line\">  -h            Print the size in a more human readable way.</span><br><span class=\"line\">  --si          Like -h, but use in SI units (powers of 1000).</span><br><span class=\"line\">  -D            Print the date of last modification or (-c) status change.</span><br><span class=\"line\">  -F            Appends '/', '=', '*', '@', '|' or '&gt;' as per ls -F.</span><br><span class=\"line\">  --inodes      Print inode number of each file.</span><br><span class=\"line\">  --device      Print device ID number to which each file belongs.</span><br><span class=\"line\">  ------- Sorting options -------</span><br><span class=\"line\">  -v            Sort files alphanumerically by version.</span><br><span class=\"line\">  -t            Sort files by last modification time.</span><br><span class=\"line\">  -c            Sort files by last status change time.</span><br><span class=\"line\">  -U            Leave files unsorted.</span><br><span class=\"line\">  -r            Reverse the order of the sort.</span><br><span class=\"line\">  --dirsfirst   List directories before files (-U disables).</span><br><span class=\"line\">  --sort X      Select sort: name,version,size,mtime,ctime.</span><br><span class=\"line\">  ------- Graphics options ------</span><br><span class=\"line\">  -i            Don't print indentation lines.</span><br><span class=\"line\">  -A            Print ANSI lines graphic indentation lines.</span><br><span class=\"line\">  -S            Print with CP437 (console) graphics indentation lines.</span><br><span class=\"line\">  -n            Turn colorization off always (-C overrides).</span><br><span class=\"line\">  -C            Turn colorization on always.</span><br><span class=\"line\">  ------- XML/HTML/JSON options -------</span><br><span class=\"line\">  -X            Prints out an XML representation of the tree.</span><br><span class=\"line\">  -J            Prints out an JSON representation of the tree.</span><br><span class=\"line\">  -H baseHREF   Prints out HTML format with baseHREF as top directory.</span><br><span class=\"line\">  -T string     Replace the default HTML title and H1 header with string.</span><br><span class=\"line\">  --nolinks     Turn off hyperlinks in HTML output.</span><br><span class=\"line\">  ---- Miscellaneous options ----</span><br><span class=\"line\">  --version     Print version and exit.</span><br><span class=\"line\">  --help        Print usage and this help message and exit.</span><br><span class=\"line\">  --            Options processing terminator.</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;命令太多？了解了一下其实常用的只有下面着三个：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-d # 只显示目录</span><br><span class=\"line\">-I # 忽略目录或文件</span><br><span class=\"line\">tree -I \"node_modules|*.png\"</span><br><span class=\"line\">-f # 显示完整路径和文件</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;上面的项目结构图我是用以下命令生成的：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tree -I \"node_modules\"</span><br></pre></td></tr></table></figure>","keywords":null,"cover":null,"content":null,"text":"1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>.<br>├── app.js               # 入口文件<br>├── bin","link":"","raw":null,"photos":[],"categories":[{"name":"Linux","slug":"Linux","count":1,"path":"api/categories/Linux.json"}],"tags":[{"name":"tree","slug":"tree","count":1,"path":"api/tags/tree.json"},{"name":"Linux","slug":"Linux","count":1,"path":"api/tags/Linux.json"}]},{"title":"TypeScript泛型","slug":"typescript-generics","date":"2018-11-04T08:00:26.000Z","updated":"2018-11-05T16:08:47.855Z","comments":true,"path":"api/articles/typescript-generics.json","excerpt":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>&emsp;&emsp;之前上手typescript+vue的时候，vue也没有完全支持typescript，当时看typescript的文档的时候，就大概的过了一遍。当时也不是很清楚如何在vue中使用typescript，更别说泛型了。</p>\n<p>&emsp;&emsp;<em>软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</em></p>\n<p>&emsp;&emsp;这是typescript官方文档的介绍，个人感觉不是太好理解，个人理解这里的组件更多的是指方法，官方的泛型示例也都是跟方法相关的。</p>\n<h4 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 无返回值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\">obj: <span class=\"built_in\">any</span></span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 有返回值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getSomething</span>(<span class=\"params\">obj: <span class=\"built_in\">any</span></span>): <span class=\"title\">any</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我在vue中就只使用了这两种，说起来也是尴尬，typescript的真正功力都没发挥出来，把typescript写成了javascript，还多堆了两个关键词的代码。其实之前在写的时候就有发现所有具有返回值的方法都指定any有何意义呢。</p>\n<p>&emsp;&emsp;typescript的基础类型也很多，如果一个方法接受一个参数直接进行返回，如果要用上强类型，是否需要写多个方法，仅仅是指定类型的不同，答案是否定的。一个方法能够接受任意类型的参数并返回相应类型的参数，就是泛型。泛型方法：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> T;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>identity</code>方法就是泛型，它接受任意类型的参数，并可以对参数类型进行捕获，并将捕获的类型返回。这样的<code>identity</code>可以适用多个类型。定义了泛型方法之后，有两种方法可以进行使用，一种是传入参数和类型，第二种是使用类型推论：</p>","keywords":null,"cover":null,"content":null,"text":"前言&emsp;&emsp;之前上手typescript+vue的时候，vue也没有完全支持typescript，当时看typescript的文档的时候，就大概的过了一遍。当时也不是很清楚如何在vue中使用typescript，更别说泛型了。&emsp;&emsp;软件工程中，我","link":"","raw":null,"photos":[],"categories":[{"name":"TypeScript","slug":"TypeScript","count":1,"path":"api/categories/TypeScript.json"}],"tags":[{"name":"TypeScript","slug":"TypeScript","count":1,"path":"api/tags/TypeScript.json"},{"name":"Generics","slug":"Generics","count":1,"path":"api/tags/Generics.json"}]},{"title":"css世界读书笔记","slug":"css-world-note","date":"2018-11-04T02:09:15.000Z","updated":"2018-11-04T17:34:45.751Z","comments":true,"path":"api/articles/css-world-note.json","excerpt":"<p>&emsp;&emsp;一直以来都觉得前端CSS可能是最难学的，emm..最难学好学精的。直到现在写CSS，有时候遇到一些小问题都不知道怎么回事，甚至有时候还会写一些无用的的属性，是在我用了语法检测才发现以前写的部分CSS其实是不正确的。有时候不明白一些属性的原理，你加很多CSS是完全不会生效的。</p>\n<p>&emsp;&emsp;遇到CSS问题的时候特别是比较棘手的问题，张鑫旭的博客中几乎都能找到。所以对于张鑫旭在CSS方面的造诣还是比较佩服的，希望能从《CSS世界》这本书中学习到不一样的东西。但是首先先就要吐槽一下，蹩脚的比喻和美式幽默的腔调确实不适合我，如果少一点废话，这本书至少可以省去1/3的篇幅。</p>\n<p>&emsp;&emsp;内容上设计上这本书着重于CSS2，比较贴近实际，CSS3新增了很多内容，也纠正了一些之前设计上的问题。如box-sizing等，但更多的则是CSS动画，使用CSS3动画相较于之前的JS动画，可以大大减少页面的重排和重绘，从而提高网页性能。但在实际开发中更注重于实现而不是动画，个人感觉动画只是点缀，提升用户体验。在实现层CSS2更为重要，学习CSS背后的技术内幕。</p>\n<p>&emsp;&emsp;相较于其他编程语言，CSS毫无逻辑可言，所有的东西都像堆叠起来的一样，所以叫层叠样式表?对于每一条CSS属性都有其作用，如一个span是属于内联元素(inline)，是不能设置width和height的，如果使用的display属性设为block、inline-block或其它块元素，就可以为其设置宽高了。例如书中在块级元素提到的清除浮动方法：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.clear</span><span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">content</span>: <span class=\"string\">''</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">\t<span class=\"attribute\">clear</span>: both;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在很长的一段时间里我都是使用clear:both，而且并不是使用伪类的方式。除了block还可以使用table、list-item.</p>\n<p>&emsp;&emsp;还有height的问题，经常会遇到设置height: 100%，实际高度永远是0，如果不明白计算方式那么永远都是0。就之前做项目的时候实现一个footer沉底，内容不足铺满一页沉底，超出页面就往下堆叠。其实思路很简单，就是footer绝对定位，bottom为0。但是代码这么写了却永远不生效。因为高度计算不正确，绝对定位就不能成功定位。vue项目中：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#app</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.footer</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">60px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在vue项目中一般footer的父元素大都不是app，可能还会有，所以这样做不ok，那么给app和footer之间的元素都加上height: 100%就可以了吗，也不行，其实实际动手试一下，调试选中app如果页面内容不足铺满屏幕，那么app的高度也不是窗口的高度，因为还少了一部分：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">html</span>, <span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","keywords":null,"cover":null,"content":null,"text":"&emsp;&emsp;一直以来都觉得前端CSS可能是最难学的，emm..最难学好学精的。直到现在写CSS，有时候遇到一些小问题都不知道怎么回事，甚至有时候还会写一些无用的的属性，是在我用了语法检测才发现以前写的部分CSS其实是不正确的。有时候不明白一些属性的原理，你加很多CSS","link":"","raw":null,"photos":[],"categories":[{"name":"css","slug":"css","count":1,"path":"api/categories/css.json"}],"tags":[{"name":"css","slug":"css","count":2,"path":"api/tags/css.json"},{"name":"读书笔记","slug":"读书笔记","count":2,"path":"api/tags/读书笔记.json"}]},{"title":"基于vue-cli3.x和typescript构建前端项目结构设计","slug":"vue-cli3-typescript-project-structure","date":"2018-10-16T10:11:41.000Z","updated":"2018-11-04T17:39:03.445Z","comments":true,"path":"api/articles/vue-cli3-typescript-project-structure.json","excerpt":"<p>&emsp;&emsp;之前在vue-cli3正式版还没有发布的时候就已经在安利下尝过鲜了，但之前对于vue-cli的设计和typescript等知识了解不多，项目结构设计的不太好。借着做另外一个项目的机会学习了vue-cli3的相关知识，根据自己的理解设计了一个前端项目结构。</p>\n<p>&emsp;&emsp;项目的技术选型用vue+typescript，脚手架使用vue-cli3，UI框架主要在ElementUI和iView之间选择。因为项目是PC中后台类型的，作为对比的就是活跃度、组件库这些，确实ElementUI是饿了么团队做的，然后活跃star这些iView也不少，明显的bug的话ELementUI比iView要多很多，也可能是使用iView的人少一点。但是iView的组件库要优于饿了么，iView是基于ant-design，个人觉得iView的UI优于饿了么。所以最后选择了iView作为UI框架，iView是基于less开发的，所以我也选用了less。这就是大概的技术选型。包管理工具这些根据个人喜好选择，我用的是yarn。</p>\n<h5 id=\"创建vue-cli3项目\"><a href=\"#创建vue-cli3项目\" class=\"headerlink\" title=\"创建vue-cli3项目\"></a>创建vue-cli3项目</h5><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 没有安装的@vue-cli3的使用下面命令安装</span></span><br><span class=\"line\">npm install -g @vue/cli</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> OR</span></span><br><span class=\"line\">yarn global add @vue/cli</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 安装完之后使用下面的命令检查是否安装正确,出版本号即正确安装</span></span><br><span class=\"line\">vue --version</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 使用vue create &lt;project_name&gt;</span></span><br><span class=\"line\">vue create my-project</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;会提示你使用默认配置还是手动设置，通过上下键切换回车选择。接着使用空格进行选择，选上Babel、TypeScript、Router、Vuex、CSS Pr-processors、Linter/Formatter，测试可以不选，回车下一步。</p>\n<p><img src=\"https://i.loli.net/2018/10/17/5bc69dc6dbf6d.png\" alt=\"step1\"></p>\n<p><img src=\"https://i.loli.net/2018/10/17/5bc69dc73dbb0.png\" alt=\"step2\"></p>\n<p><img src=\"https://i.loli.net/2018/10/17/5bc69dc79e4a8.png\" alt=\"step3\"></p>\n<p>&emsp;&emsp;创建好的项目结构：</p>\n<p><img src=\"https://i.loli.net/2018/10/17/5bc6a69993d88.png\" alt=\"项目结构\"></p>","keywords":null,"cover":"https://i.loli.net/2018/10/17/5bc69dc6dbf6d.png","content":null,"text":"&emsp;&emsp;之前在vue-cli3正式版还没有发布的时候就已经在安利下尝过鲜了，但之前对于vue-cli的设计和typescript等知识了解不多，项目结构设计的不太好。借着做另外一个项目的机会学习了vue-cli3的相关知识，根据自己的理解设计了一个前端项目结构。&","link":"","raw":null,"photos":[],"categories":[{"name":"vue","slug":"vue","count":7,"path":"api/categories/vue.json"}],"tags":[{"name":"vue","slug":"vue","count":1,"path":"api/tags/vue.json"},{"name":"vue-cli3","slug":"vue-cli3","count":1,"path":"api/tags/vue-cli3.json"},{"name":"typescript","slug":"typescript","count":1,"path":"api/tags/typescript.json"}]},{"title":"原生javascript实现canvas图形验证码","slug":"javascript-canvas-verify-code","date":"2018-10-14T12:24:50.000Z","updated":"2018-10-14T16:34:19.524Z","comments":true,"path":"api/articles/javascript-canvas-verify-code.json","excerpt":"<p>&emsp;&emsp;感觉自己最近好像很少拿原生js写东西了，自己的js水平也还有待提高。上周做原型设计的时候设计了一个图形验证码，感觉这么小一个东西也没必要去找个库，就打算自己造个小轮子来用了。</p>\n<p>&emsp;&emsp;图形验证码的作用是一种人机识别的手段，目的是为了区分正常人和机器人，所以没必要设计的太麻烦(12306之前的验证码简直!!)，所以就采用数字+大小写字母共4个字符进行验证，用canvas进行绘制，如果只是简单这样也太简单了，像接触到的其他网站使用的验证码还有背景色和干扰的线条，基本上这就是实现的思路了。</p>\n<hr>\n<p>&emsp;&emsp;根据实现的思路，随机颜色的方法、生成随机数的方法肯定是需要的。</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 生成一个随机数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">function randomNum(<span class=\"built_in\">min</span>, <span class=\"built_in\">max</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Math.<span class=\"built_in\">floor</span>(Math.<span class=\"built_in\">random</span>() * (<span class=\"built_in\">max</span> - <span class=\"built_in\">min</span>) + <span class=\"built_in\">min</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 生成随机颜色rgb值</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">function randomColor(<span class=\"built_in\">min</span>, <span class=\"built_in\">max</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> r = randomNum(<span class=\"built_in\">min</span>, <span class=\"built_in\">max</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> g = randomNum(<span class=\"built_in\">min</span>, <span class=\"built_in\">max</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> b = randomNum(<span class=\"built_in\">min</span>, <span class=\"built_in\">max</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> `rgb($&#123;r&#125;, $&#123;g&#125;, $&#123;b&#125;)`;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>&emsp;&emsp;在html我们只要需要提供一个容器就可以了，调用时传容器id，以及图形验证码的size就可以了。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"verifyContainer\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;获取到容器和size之后，我们得先添加一个canvas，参考了下网上其他验证码的背景色大概都在160-240左右可能这个区间的颜色会偏浅一点。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 向html添加canvas</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">appendCanvas</span>(<span class=\"params\">id, width, height</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> container = <span class=\"built_in\">document</span>.getElementById(id);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> canvas = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'canvas'</span>);</span><br><span class=\"line\">    canvas.width = width;</span><br><span class=\"line\">    canvas.height = height;</span><br><span class=\"line\">    canvas.style.backgroundColor = randomColor(<span class=\"number\">160</span>, <span class=\"number\">240</span>);</span><br><span class=\"line\">    container.appendChild(canvas);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","keywords":null,"cover":null,"content":null,"text":"&emsp;&emsp;感觉自己最近好像很少拿原生js写东西了，自己的js水平也还有待提高。上周做原型设计的时候设计了一个图形验证码，感觉这么小一个东西也没必要去找个库，就打算自己造个小轮子来用了。&emsp;&emsp;图形验证码的作用是一种人机识别的手段，目的是为了区分正常人","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":4,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":2,"path":"api/tags/javascript.json"},{"name":"验证码","slug":"验证码","count":1,"path":"api/tags/验证码.json"}]},{"title":"使用charles进行APP抓包简单教程","slug":"use-charles","date":"2018-10-07T07:32:04.000Z","updated":"2018-10-14T16:36:23.394Z","comments":true,"path":"api/articles/use-charles.json","excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>&emsp;&emsp;本来想趁国庆写个小工具来自动预约单车，手动确实太麻烦了，时间掌握不好，车就被别人骑走了。做这个小工具最重要的步骤就是抓到摩拜和哈罗的api，选择了charles这款抓包工具，是挺好用的，不够也需要付费。</p>\n<p>&emsp;&emsp;之前定好的计划一点点被打乱，高速一日游这种就不说了t.t，结果用charles抓包才发现好像别人也不傻，api都是加密的，导致小工具就暂时搁置了。那么就先来记录下如何使用charles抓取app的api吧。</p>\n<h2 id=\"PC设置\"><a href=\"#PC设置\" class=\"headerlink\" title=\"PC设置\"></a>PC设置</h2><p>&emsp;&emsp;开始之前得保证你下载并安装了charles，有关如何安装就不赘述了，另外得保证wifi环境下。</p>\n<p><img src=\"https://i.loli.net/2018/10/07/5bba1be006793.png\" alt=\"proxy设置\"></p>\n<p>&emsp;&emsp;Step1: 点击proxy settings进行代理设置，填上代理端口号默认是8888，激活http代理。</p>\n<p><img src=\"https://i.loli.net/2018/10/07/5bba1be032586.png\" alt=\"proxy mobile\"></p>\n<p>&emsp;&emsp;Step2: 因为只需要抓手机APP，所以不需要代理pc，将macOS Proxy勾选去掉。</p>\n<h2 id=\"手机设置\"><a href=\"#手机设置\" class=\"headerlink\" title=\"手机设置\"></a>手机设置</h2>","keywords":null,"cover":"https://i.loli.net/2018/10/07/5bba1be006793.png","content":null,"text":"前言&emsp;&emsp;本来想趁国庆写个小工具来自动预约单车，手动确实太麻烦了，时间掌握不好，车就被别人骑走了。做这个小工具最重要的步骤就是抓到摩拜和哈罗的api，选择了charles这款抓包工具，是挺好用的，不够也需要付费。&emsp;&emsp;之前定好的计划一点点被打乱","link":"","raw":null,"photos":[],"categories":[{"name":"抓包","slug":"抓包","count":1,"path":"api/categories/抓包.json"}],"tags":[{"name":"charles","slug":"charles","count":1,"path":"api/tags/charles.json"},{"name":"抓包","slug":"抓包","count":1,"path":"api/tags/抓包.json"}]},{"title":"Git权威指南读书笔记","slug":"definitity-guide-of-git","date":"2018-10-07T04:21:04.000Z","updated":"2018-10-07T13:33:06.612Z","comments":true,"path":"api/articles/definitity-guide-of-git.json","excerpt":"<p>&emsp;&emsp;对于git的接触我也算较晚的，应该是到了大二会有一些团队项目，才开始使用git。也仅仅局限于简单的了解，对于很多原理都不了解，出了问题，就只有找百度。在实验室老师也只推崇svn，当时也是一个接近10人的团队提交代码。大家也都是用的GUI，记得当时三天两头就会出问题。后来因为要找实习就转到git上来了，而且大部分开源项目都发布在github等社区。后来在工作中又出过事故，觉得还是得好好了解下git。在推荐下看了git权威指南这本书。</p>\n<p>&emsp;&emsp;这本书怎么说呢？有亮点也有缺点，这是必然的。先说亮点，文章条理和章节设计非常合理，而且在前言里还推荐了不同人群的阅读重点。根据阅读重点，我基本上第一篇就是简单阅读掠过，第二篇就也粗略的过了一下，相比第一篇投入时间的更多一些，第三篇是作者推荐的重点阅读篇，花的时间较多，但是很多东西接触的不多或者甚至没有接触，所以读起来有些晦涩的感觉。结合作者的例子读起来稍好一些，然后作者讲了一些git背后的原理，对于想知其然，知其所以然还是比较好。然后缺点的话，确实有点太啰嗦了，有点影响阅读，比如花了30多页的篇幅去讲在不同操作系统下git的安装，我觉得是没那么必要的。再有就是从“权威指南”这四个字，我觉得定位不那么合理，我认为的权威指南是类似犀牛书那种的，什么操作、命令之类的忘记了，我可以查权威指南解决问题的。总之就是涵盖的东西确实很广，但是定位不够明确，针对的读者用户群较广，就感觉被捆绑消费了，感觉大多数人可能会抱着如何用好git或者了解如果搭建git、迁移到git这两方面或者更多。另外介绍cvs、svn以及其他版本控制系统，个人觉得没什么必要，要么别人是受够了svn转git对svn已经很了解了，要么是没有接触过svn想直接入门git的，所以介绍了只是徒增阅读时间罢了。</p>\n<p>&emsp;&emsp;再来说我读了之后感觉提升还是蛮大的，至少不会再像之前不知道stash，在一个分支下改了一些东西，要切到另一个分支，自己傻傻的将修改的内容全部还原再切换分支，然后又从头来过，简直被自己蠢哭。然后对git的基本操作了解的更多了，对于解决冲突、分支有了进一步的了解。提升的话可能较之前好得多，但还是有些地方理解的不深刻，对本书有了一定了解之后，感觉有些地方还需要花时间精读，另外在使用git中碰到问题回来查印象肯定也会更深刻一些。</p>\n","keywords":null,"cover":null,"content":null,"text":"&emsp;&emsp;对于git的接触我也算较晚的，应该是到了大二会有一些团队项目，才开始使用git。也仅仅局限于简单的了解，对于很多原理都不了解，出了问题，就只有找百度。在实验室老师也只推崇svn，当时也是一个接近10人的团队提交代码。大家也都是用的GUI，记得当时三天两头就","link":"","raw":null,"photos":[],"categories":[{"name":"git","slug":"git","count":1,"path":"api/categories/git.json"}],"tags":[{"name":"读书笔记","slug":"读书笔记","count":2,"path":"api/tags/读书笔记.json"},{"name":"git","slug":"git","count":1,"path":"api/tags/git.json"}]},{"title":"unity-cache-server-cache-modules","slug":"unity-cache-server-cache-modules","date":"2018-09-28T02:43:06.000Z","updated":"2018-10-02T15:01:49.428Z","comments":true,"path":"api/articles/unity-cache-server-cache-modules.json","excerpt":"<h2 id=\"Cache-Modules\"><a href=\"#Cache-Modules\" class=\"headerlink\" title=\"Cache Modules\"></a>Cache Modules</h2><p>&emsp;&emsp;Unity-cache-server v6的缓存服务器支持两种缓存机制：</p>\n<ul>\n<li>cache_fs，基于文件系统的缓存</li>\n<li>完全内存（RAM）支持的缓存</li>\n</ul>\n<p>&emsp;&emsp;cache server默认使用cache_fs即文件系统缓存模式，适用于大多数的应用程序。RAM缓存模式提供最佳性能，但Server需要足够的物理RAM用于缓存，通常需要的内存大小至少为项目Library文件夹的2-3倍。</p>\n<p>&emsp;&emsp;两个模式的配置文件信息都在config/defalult.yml中进行配置。</p>\n<h2 id=\"cache-fs\"><a href=\"#cache-fs\" class=\"headerlink\" title=\"cache_fs\"></a>cache_fs</h2><p>&emsp;&emsp;一个简单且高效的文件系统缓存模式。</p>\n<p><strong>用法</strong></p>\n<p><code>--cache-module cache_fs</code></p>\n<p><strong>命令</strong></p>","keywords":null,"cover":null,"content":null,"text":"Cache Modules&emsp;&emsp;Unity-cache-server v6的缓存服务器支持两种缓存机制：cache_fs，基于文件系统的缓存完全内存（RAM）支持的缓存&emsp;&emsp;cache server默认使用cache_fs即文件系统缓存模式，适","link":"","raw":null,"photos":[],"categories":[{"name":"unity","slug":"unity","count":2,"path":"api/categories/unity.json"}],"tags":[{"name":"cacheserver","slug":"cacheserver","count":2,"path":"api/tags/cacheserver.json"}]}]}