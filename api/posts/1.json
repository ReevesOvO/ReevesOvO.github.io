{"total":22,"pageSize":10,"pageCount":3,"data":[{"title":"TypeScript泛型","slug":"typescript-generics","date":"2018-11-04T08:00:26.000Z","updated":"2018-11-05T16:08:47.855Z","comments":true,"path":"api/articles/typescript-generics.json","excerpt":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>&emsp;&emsp;之前上手typescript+vue的时候，vue也没有完全支持typescript，当时看typescript的文档的时候，就大概的过了一遍。当时也不是很清楚如何在vue中使用typescript，更别说泛型了。</p>\n<p>&emsp;&emsp;<em>软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</em></p>\n<p>&emsp;&emsp;这是typescript官方文档的介绍，个人感觉不是太好理解，个人理解这里的组件更多的是指方法，官方的泛型示例也都是跟方法相关的。</p>\n<h4 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 无返回值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\">obj: <span class=\"built_in\">any</span></span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 有返回值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getSomething</span>(<span class=\"params\">obj: <span class=\"built_in\">any</span></span>): <span class=\"title\">any</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我在vue中就只使用了这两种，说起来也是尴尬，typescript的真正功力都没发挥出来，把typescript写成了javascript，还多堆了两个关键词的代码。其实之前在写的时候就有发现所有具有返回值的方法都指定any有何意义呢。</p>\n<p>&emsp;&emsp;typescript的基础类型也很多，如果一个方法接受一个参数直接进行返回，如果要用上强类型，是否需要写多个方法，仅仅是指定类型的不同，答案是否定的。一个方法能够接受任意类型的参数并返回相应类型的参数，就是泛型。泛型方法：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> T;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>identity</code>方法就是泛型，它接受任意类型的参数，并可以对参数类型进行捕获，并将捕获的类型返回。这样的<code>identity</code>可以适用多个类型。定义了泛型方法之后，有两种方法可以进行使用，一种是传入参数和类型，第二种是使用类型推论：</p>","keywords":null,"cover":null,"content":null,"text":"前言&emsp;&emsp;之前上手typescript+vue的时候，vue也没有完全支持typescript，当时看typescript的文档的时候，就大概的过了一遍。当时也不是很清楚如何在vue中使用typescript，更别说泛型了。&emsp;&emsp;软件工程中，我","link":"","raw":null,"photos":[],"categories":[{"name":"TypeScript","slug":"TypeScript","count":1,"path":"api/categories/TypeScript.json"}],"tags":[{"name":"TypeScript","slug":"TypeScript","count":1,"path":"api/tags/TypeScript.json"},{"name":"Generics","slug":"Generics","count":1,"path":"api/tags/Generics.json"}]},{"title":"css世界读书笔记","slug":"css-world-note","date":"2018-11-04T02:09:15.000Z","updated":"2018-11-04T17:34:45.751Z","comments":true,"path":"api/articles/css-world-note.json","excerpt":"<p>&emsp;&emsp;一直以来都觉得前端CSS可能是最难学的，emm..最难学好学精的。直到现在写CSS，有时候遇到一些小问题都不知道怎么回事，甚至有时候还会写一些无用的的属性，是在我用了语法检测才发现以前写的部分CSS其实是不正确的。有时候不明白一些属性的原理，你加很多CSS是完全不会生效的。</p>\n<p>&emsp;&emsp;遇到CSS问题的时候特别是比较棘手的问题，张鑫旭的博客中几乎都能找到。所以对于张鑫旭在CSS方面的造诣还是比较佩服的，希望能从《CSS世界》这本书中学习到不一样的东西。但是首先先就要吐槽一下，蹩脚的比喻和美式幽默的腔调确实不适合我，如果少一点废话，这本书至少可以省去1/3的篇幅。</p>\n<p>&emsp;&emsp;内容上设计上这本书着重于CSS2，比较贴近实际，CSS3新增了很多内容，也纠正了一些之前设计上的问题。如box-sizing等，但更多的则是CSS动画，使用CSS3动画相较于之前的JS动画，可以大大减少页面的重排和重绘，从而提高网页性能。但在实际开发中更注重于实现而不是动画，个人感觉动画只是点缀，提升用户体验。在实现层CSS2更为重要，学习CSS背后的技术内幕。</p>\n<p>&emsp;&emsp;相较于其他编程语言，CSS毫无逻辑可言，所有的东西都像堆叠起来的一样，所以叫层叠样式表?对于每一条CSS属性都有其作用，如一个span是属于内联元素(inline)，是不能设置width和height的，如果使用的display属性设为block、inline-block或其它块元素，就可以为其设置宽高了。例如书中在块级元素提到的清除浮动方法：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.clear</span><span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">content</span>: <span class=\"string\">''</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">\t<span class=\"attribute\">clear</span>: both;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在很长的一段时间里我都是使用clear:both，而且并不是使用伪类的方式。除了block还可以使用table、list-item.</p>\n<p>&emsp;&emsp;还有height的问题，经常会遇到设置height: 100%，实际高度永远是0，如果不明白计算方式那么永远都是0。就之前做项目的时候实现一个footer沉底，内容不足铺满一页沉底，超出页面就往下堆叠。其实思路很简单，就是footer绝对定位，bottom为0。但是代码这么写了却永远不生效。因为高度计算不正确，绝对定位就不能成功定位。vue项目中：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#app</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.footer</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">60px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在vue项目中一般footer的父元素大都不是app，可能还会有，所以这样做不ok，那么给app和footer之间的元素都加上height: 100%就可以了吗，也不行，其实实际动手试一下，调试选中app如果页面内容不足铺满屏幕，那么app的高度也不是窗口的高度，因为还少了一部分：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">html</span>, <span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","keywords":null,"cover":null,"content":null,"text":"&emsp;&emsp;一直以来都觉得前端CSS可能是最难学的，emm..最难学好学精的。直到现在写CSS，有时候遇到一些小问题都不知道怎么回事，甚至有时候还会写一些无用的的属性，是在我用了语法检测才发现以前写的部分CSS其实是不正确的。有时候不明白一些属性的原理，你加很多CSS","link":"","raw":null,"photos":[],"categories":[{"name":"css","slug":"css","count":1,"path":"api/categories/css.json"}],"tags":[{"name":"css","slug":"css","count":2,"path":"api/tags/css.json"},{"name":"读书笔记","slug":"读书笔记","count":2,"path":"api/tags/读书笔记.json"}]},{"title":"基于vue-cli3.x和typescript构建前端项目结构设计","slug":"vue-cli3-typescript-project-structure","date":"2018-10-16T10:11:41.000Z","updated":"2018-11-04T17:39:03.445Z","comments":true,"path":"api/articles/vue-cli3-typescript-project-structure.json","excerpt":"<p>&emsp;&emsp;之前在vue-cli3正式版还没有发布的时候就已经在安利下尝过鲜了，但之前对于vue-cli的设计和typescript等知识了解不多，项目结构设计的不太好。借着做另外一个项目的机会学习了vue-cli3的相关知识，根据自己的理解设计了一个前端项目结构。</p>\n<p>&emsp;&emsp;项目的技术选型用vue+typescript，脚手架使用vue-cli3，UI框架主要在ElementUI和iView之间选择。因为项目是PC中后台类型的，作为对比的就是活跃度、组件库这些，确实ElementUI是饿了么团队做的，然后活跃star这些iView也不少，明显的bug的话ELementUI比iView要多很多，也可能是使用iView的人少一点。但是iView的组件库要优于饿了么，iView是基于ant-design，个人觉得iView的UI优于饿了么。所以最后选择了iView作为UI框架，iView是基于less开发的，所以我也选用了less。这就是大概的技术选型。包管理工具这些根据个人喜好选择，我用的是yarn。</p>\n<h5 id=\"创建vue-cli3项目\"><a href=\"#创建vue-cli3项目\" class=\"headerlink\" title=\"创建vue-cli3项目\"></a>创建vue-cli3项目</h5><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 没有安装的@vue-cli3的使用下面命令安装</span></span><br><span class=\"line\">npm install -g @vue/cli</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> OR</span></span><br><span class=\"line\">yarn global add @vue/cli</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 安装完之后使用下面的命令检查是否安装正确,出版本号即正确安装</span></span><br><span class=\"line\">vue --version</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 使用vue create &lt;project_name&gt;</span></span><br><span class=\"line\">vue create my-project</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;会提示你使用默认配置还是手动设置，通过上下键切换回车选择。接着使用空格进行选择，选上Babel、TypeScript、Router、Vuex、CSS Pr-processors、Linter/Formatter，测试可以不选，回车下一步。</p>\n<p><img src=\"https://i.loli.net/2018/10/17/5bc69dc6dbf6d.png\" alt=\"step1\"></p>\n<p><img src=\"https://i.loli.net/2018/10/17/5bc69dc73dbb0.png\" alt=\"step2\"></p>\n<p><img src=\"https://i.loli.net/2018/10/17/5bc69dc79e4a8.png\" alt=\"step3\"></p>\n<p>&emsp;&emsp;创建好的项目结构：</p>\n<p><img src=\"https://i.loli.net/2018/10/17/5bc6a69993d88.png\" alt=\"项目结构\"></p>","keywords":null,"cover":"https://i.loli.net/2018/10/17/5bc69dc6dbf6d.png","content":null,"text":"&emsp;&emsp;之前在vue-cli3正式版还没有发布的时候就已经在安利下尝过鲜了，但之前对于vue-cli的设计和typescript等知识了解不多，项目结构设计的不太好。借着做另外一个项目的机会学习了vue-cli3的相关知识，根据自己的理解设计了一个前端项目结构。&","link":"","raw":null,"photos":[],"categories":[{"name":"vue","slug":"vue","count":7,"path":"api/categories/vue.json"}],"tags":[{"name":"vue","slug":"vue","count":1,"path":"api/tags/vue.json"},{"name":"vue-cli3","slug":"vue-cli3","count":1,"path":"api/tags/vue-cli3.json"},{"name":"typescript","slug":"typescript","count":1,"path":"api/tags/typescript.json"}]},{"title":"原生javascript实现canvas图形验证码","slug":"javascript-canvas-verify-code","date":"2018-10-14T12:24:50.000Z","updated":"2018-10-14T16:34:19.524Z","comments":true,"path":"api/articles/javascript-canvas-verify-code.json","excerpt":"<p>&emsp;&emsp;感觉自己最近好像很少拿原生js写东西了，自己的js水平也还有待提高。上周做原型设计的时候设计了一个图形验证码，感觉这么小一个东西也没必要去找个库，就打算自己造个小轮子来用了。</p>\n<p>&emsp;&emsp;图形验证码的作用是一种人机识别的手段，目的是为了区分正常人和机器人，所以没必要设计的太麻烦(12306之前的验证码简直!!)，所以就采用数字+大小写字母共4个字符进行验证，用canvas进行绘制，如果只是简单这样也太简单了，像接触到的其他网站使用的验证码还有背景色和干扰的线条，基本上这就是实现的思路了。</p>\n<hr>\n<p>&emsp;&emsp;根据实现的思路，随机颜色的方法、生成随机数的方法肯定是需要的。</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 生成一个随机数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">function randomNum(<span class=\"built_in\">min</span>, <span class=\"built_in\">max</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Math.<span class=\"built_in\">floor</span>(Math.<span class=\"built_in\">random</span>() * (<span class=\"built_in\">max</span> - <span class=\"built_in\">min</span>) + <span class=\"built_in\">min</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 生成随机颜色rgb值</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">function randomColor(<span class=\"built_in\">min</span>, <span class=\"built_in\">max</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> r = randomNum(<span class=\"built_in\">min</span>, <span class=\"built_in\">max</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> g = randomNum(<span class=\"built_in\">min</span>, <span class=\"built_in\">max</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> b = randomNum(<span class=\"built_in\">min</span>, <span class=\"built_in\">max</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> `rgb($&#123;r&#125;, $&#123;g&#125;, $&#123;b&#125;)`;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>&emsp;&emsp;在html我们只要需要提供一个容器就可以了，调用时传容器id，以及图形验证码的size就可以了。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"verifyContainer\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;获取到容器和size之后，我们得先添加一个canvas，参考了下网上其他验证码的背景色大概都在160-240左右可能这个区间的颜色会偏浅一点。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 向html添加canvas</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">appendCanvas</span>(<span class=\"params\">id, width, height</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> container = <span class=\"built_in\">document</span>.getElementById(id);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> canvas = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'canvas'</span>);</span><br><span class=\"line\">    canvas.width = width;</span><br><span class=\"line\">    canvas.height = height;</span><br><span class=\"line\">    canvas.style.backgroundColor = randomColor(<span class=\"number\">160</span>, <span class=\"number\">240</span>);</span><br><span class=\"line\">    container.appendChild(canvas);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","keywords":null,"cover":null,"content":null,"text":"&emsp;&emsp;感觉自己最近好像很少拿原生js写东西了，自己的js水平也还有待提高。上周做原型设计的时候设计了一个图形验证码，感觉这么小一个东西也没必要去找个库，就打算自己造个小轮子来用了。&emsp;&emsp;图形验证码的作用是一种人机识别的手段，目的是为了区分正常人","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":4,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":2,"path":"api/tags/javascript.json"},{"name":"验证码","slug":"验证码","count":1,"path":"api/tags/验证码.json"}]},{"title":"使用charles进行APP抓包简单教程","slug":"use-charles","date":"2018-10-07T07:32:04.000Z","updated":"2018-10-14T16:36:23.394Z","comments":true,"path":"api/articles/use-charles.json","excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>&emsp;&emsp;本来想趁国庆写个小工具来自动预约单车，手动确实太麻烦了，时间掌握不好，车就被别人骑走了。做这个小工具最重要的步骤就是抓到摩拜和哈罗的api，选择了charles这款抓包工具，是挺好用的，不够也需要付费。</p>\n<p>&emsp;&emsp;之前定好的计划一点点被打乱，高速一日游这种就不说了t.t，结果用charles抓包才发现好像别人也不傻，api都是加密的，导致小工具就暂时搁置了。那么就先来记录下如何使用charles抓取app的api吧。</p>\n<h2 id=\"PC设置\"><a href=\"#PC设置\" class=\"headerlink\" title=\"PC设置\"></a>PC设置</h2><p>&emsp;&emsp;开始之前得保证你下载并安装了charles，有关如何安装就不赘述了，另外得保证wifi环境下。</p>\n<p><img src=\"https://i.loli.net/2018/10/07/5bba1be006793.png\" alt=\"proxy设置\"></p>\n<p>&emsp;&emsp;Step1: 点击proxy settings进行代理设置，填上代理端口号默认是8888，激活http代理。</p>\n<p><img src=\"https://i.loli.net/2018/10/07/5bba1be032586.png\" alt=\"proxy mobile\"></p>\n<p>&emsp;&emsp;Step2: 因为只需要抓手机APP，所以不需要代理pc，将macOS Proxy勾选去掉。</p>\n<h2 id=\"手机设置\"><a href=\"#手机设置\" class=\"headerlink\" title=\"手机设置\"></a>手机设置</h2>","keywords":null,"cover":"https://i.loli.net/2018/10/07/5bba1be006793.png","content":null,"text":"前言&emsp;&emsp;本来想趁国庆写个小工具来自动预约单车，手动确实太麻烦了，时间掌握不好，车就被别人骑走了。做这个小工具最重要的步骤就是抓到摩拜和哈罗的api，选择了charles这款抓包工具，是挺好用的，不够也需要付费。&emsp;&emsp;之前定好的计划一点点被打乱","link":"","raw":null,"photos":[],"categories":[{"name":"抓包","slug":"抓包","count":1,"path":"api/categories/抓包.json"}],"tags":[{"name":"charles","slug":"charles","count":1,"path":"api/tags/charles.json"},{"name":"抓包","slug":"抓包","count":1,"path":"api/tags/抓包.json"}]},{"title":"Git权威指南读书笔记","slug":"definitity-guide-of-git","date":"2018-10-07T04:21:04.000Z","updated":"2018-10-07T13:33:06.612Z","comments":true,"path":"api/articles/definitity-guide-of-git.json","excerpt":"<p>&emsp;&emsp;对于git的接触我也算较晚的，应该是到了大二会有一些团队项目，才开始使用git。也仅仅局限于简单的了解，对于很多原理都不了解，出了问题，就只有找百度。在实验室老师也只推崇svn，当时也是一个接近10人的团队提交代码。大家也都是用的GUI，记得当时三天两头就会出问题。后来因为要找实习就转到git上来了，而且大部分开源项目都发布在github等社区。后来在工作中又出过事故，觉得还是得好好了解下git。在推荐下看了git权威指南这本书。</p>\n<p>&emsp;&emsp;这本书怎么说呢？有亮点也有缺点，这是必然的。先说亮点，文章条理和章节设计非常合理，而且在前言里还推荐了不同人群的阅读重点。根据阅读重点，我基本上第一篇就是简单阅读掠过，第二篇就也粗略的过了一下，相比第一篇投入时间的更多一些，第三篇是作者推荐的重点阅读篇，花的时间较多，但是很多东西接触的不多或者甚至没有接触，所以读起来有些晦涩的感觉。结合作者的例子读起来稍好一些，然后作者讲了一些git背后的原理，对于想知其然，知其所以然还是比较好。然后缺点的话，确实有点太啰嗦了，有点影响阅读，比如花了30多页的篇幅去讲在不同操作系统下git的安装，我觉得是没那么必要的。再有就是从“权威指南”这四个字，我觉得定位不那么合理，我认为的权威指南是类似犀牛书那种的，什么操作、命令之类的忘记了，我可以查权威指南解决问题的。总之就是涵盖的东西确实很广，但是定位不够明确，针对的读者用户群较广，就感觉被捆绑消费了，感觉大多数人可能会抱着如何用好git或者了解如果搭建git、迁移到git这两方面或者更多。另外介绍cvs、svn以及其他版本控制系统，个人觉得没什么必要，要么别人是受够了svn转git对svn已经很了解了，要么是没有接触过svn想直接入门git的，所以介绍了只是徒增阅读时间罢了。</p>\n<p>&emsp;&emsp;再来说我读了之后感觉提升还是蛮大的，至少不会再像之前不知道stash，在一个分支下改了一些东西，要切到另一个分支，自己傻傻的将修改的内容全部还原再切换分支，然后又从头来过，简直被自己蠢哭。然后对git的基本操作了解的更多了，对于解决冲突、分支有了进一步的了解。提升的话可能较之前好得多，但还是有些地方理解的不深刻，对本书有了一定了解之后，感觉有些地方还需要花时间精读，另外在使用git中碰到问题回来查印象肯定也会更深刻一些。</p>\n","keywords":null,"cover":null,"content":null,"text":"&emsp;&emsp;对于git的接触我也算较晚的，应该是到了大二会有一些团队项目，才开始使用git。也仅仅局限于简单的了解，对于很多原理都不了解，出了问题，就只有找百度。在实验室老师也只推崇svn，当时也是一个接近10人的团队提交代码。大家也都是用的GUI，记得当时三天两头就","link":"","raw":null,"photos":[],"categories":[{"name":"git","slug":"git","count":1,"path":"api/categories/git.json"}],"tags":[{"name":"读书笔记","slug":"读书笔记","count":2,"path":"api/tags/读书笔记.json"},{"name":"git","slug":"git","count":1,"path":"api/tags/git.json"}]},{"title":"unity-cache-server-cache-modules","slug":"unity-cache-server-cache-modules","date":"2018-09-28T02:43:06.000Z","updated":"2018-10-02T15:01:49.428Z","comments":true,"path":"api/articles/unity-cache-server-cache-modules.json","excerpt":"<h2 id=\"Cache-Modules\"><a href=\"#Cache-Modules\" class=\"headerlink\" title=\"Cache Modules\"></a>Cache Modules</h2><p>&emsp;&emsp;Unity-cache-server v6的缓存服务器支持两种缓存机制：</p>\n<ul>\n<li>cache_fs，基于文件系统的缓存</li>\n<li>完全内存（RAM）支持的缓存</li>\n</ul>\n<p>&emsp;&emsp;cache server默认使用cache_fs即文件系统缓存模式，适用于大多数的应用程序。RAM缓存模式提供最佳性能，但Server需要足够的物理RAM用于缓存，通常需要的内存大小至少为项目Library文件夹的2-3倍。</p>\n<p>&emsp;&emsp;两个模式的配置文件信息都在config/defalult.yml中进行配置。</p>\n<h2 id=\"cache-fs\"><a href=\"#cache-fs\" class=\"headerlink\" title=\"cache_fs\"></a>cache_fs</h2><p>&emsp;&emsp;一个简单且高效的文件系统缓存模式。</p>\n<p><strong>用法</strong></p>\n<p><code>--cache-module cache_fs</code></p>\n<p><strong>命令</strong></p>","keywords":null,"cover":null,"content":null,"text":"Cache Modules&emsp;&emsp;Unity-cache-server v6的缓存服务器支持两种缓存机制：cache_fs，基于文件系统的缓存完全内存（RAM）支持的缓存&emsp;&emsp;cache server默认使用cache_fs即文件系统缓存模式，适","link":"","raw":null,"photos":[],"categories":[{"name":"unity","slug":"unity","count":2,"path":"api/categories/unity.json"}],"tags":[{"name":"cacheserver","slug":"cacheserver","count":2,"path":"api/tags/cacheserver.json"}]},{"title":"Unity-Cache-Server","slug":"unity-cache-server","date":"2018-09-26T01:38:21.000Z","updated":"2018-11-06T08:01:02.319Z","comments":true,"path":"api/articles/unity-cache-server.json","excerpt":"<p><em>注：由于没有做过游戏开发，也没有使用过unity，所以有问题的地方欢迎在评论指正</em></p>\n<h2 id=\"缓存服务器\"><a href=\"#缓存服务器\" class=\"headerlink\" title=\"缓存服务器\"></a>缓存服务器</h2><p>&emsp;&emsp;Unity的打包流程中最慢的环节就是贴图的压缩。不同的平台，需要把原始贴图压缩成对应平台的压缩贴图格式。iOS和Android平台对应的格式不同。针对这个问题，Unity官方给出了一个CacheServer的解决方案。CacheServer只是一个文件cache服务器，记录了贴图源文件和转换参数(meta文件)以及转换器版本等信息构成的字符串的md5值作为文件索引。第一个做转换的人，在本地进行压缩后，会把结果传到CacheServer，其他人使用时，就会优先去看有没有人做过同样的工作，如果有就从cache服务器下载资源，没有就会进行压缩，并上传结果到CacheServer。如果源文件、转换参数都完全一样，结果会被缓存。在日常所有贴图都会被压缩过，可以节约压缩贴图的时间，从而减少打包时间。</p>\n<p>&emsp;&emsp;Unity官方在3月发布了Cache Server v6.0.0版本，官方宣称6.0带来了更高的可靠性和性能，以及一系列的新功能。包括新模块化，实现最大的I/O性能，支持高性能的缓存模式等等。</p>\n<p>&emsp;&emsp;Unity用户手册中也有关于Cache Server介绍和使用，但截至9.26日，官网的用户手册还停留在2月份的，没有做更新。关于文件更改请仔细阅读官网手册英文原文说明或下方翻译：</p>\n<blockquote>\n<p>关于缓存服务器，Unity具有一个全自动的资源管道。当修改了类似于<code>.psd</code>或<code>.fbx</code>文件的资源后，Unity将检测到更改并自动重新导入更改后的文件。从文件导入的数据之后将由Unity按其内部格式存储。资源管道最重要的部分是“热重载”功能和保证您的所有资源始终同步为所见即所得模式。此功能的实现也是要付出代价的。任何修改的资源必须重新导入。在一个大团队中工作时，获得了最新的管理源代码(Source Control)后，您通常需要等很长一段时间才可将所有其他成员修改或创建的资源重新导入完成。另外，在PC和移动平台之间来回切换工程平台，也将引发重新导入大部分资源的操作。</p>\n<p>在<strong>缓存服务器(Cache Server)</strong>上缓存导入的资源数据可大幅缩短导入资源占用的时间。</p>\n<p>缓存每个导入的资源基于：</p>\n<p>&emsp;&emsp;<em>资源文件本身</em></p>\n<p>&emsp;&emsp;<em>导入设置</em></p>\n<p>&emsp;&emsp;<em>资源导入器版本</em></p>\n<p>&emsp;&emsp;<em>当前平台</em></p>\n<p>如果上述四项任意一项发生变化，资源将重新导入，否则，会从缓存服务器(Cache Server)下载更新后的资源。启用偏好设置(Preferences)中的缓存服务器后，您可以共享多个工程的导入资源。</p>\n<p><strong><em>注意：将缓存服务器设置好后，这个过程将是完全自动的，这意味着无需其他工作流程。它只是缩短了导入工程的时间，无需您进行操作。</em></strong></p>\n</blockquote>\n<h2 id=\"配置要求\"><a href=\"#配置要求\" class=\"headerlink\" title=\"配置要求\"></a>配置要求</h2><p>&emsp;&emsp;只考虑将CacheServer搭在本地环境，cache服务器不同于版本控制，其缓存数据可以随时在本地重建，没必要使用远程服务器。如果存在开发团队分布在各地的情况，选择在每个地方配置一台独立缓存服务器比较好。</p>\n<p>&emsp;&emsp;因为CacheServer只相当于一个文件cache服务器，所以配置并不需要太高。但是为了最佳性能，机器必须要有足够的RAM来存储整个导入的工程文件夹。机器最好使用SSD，保证读写速度。另外CacheServer的CPU使用率非常低。最好使用Linux或Mac OS X系统。Windows 文件系统未对资源缓存服务器 (Asset Cache Server) 存储数据的方式进行特别理想的优化，Windows 上的文件锁定问题可引发问题，但 Linux 或 Mac OS X 上不会出现此类问题。</p>\n<h2 id=\"用户使用\"><a href=\"#用户使用\" class=\"headerlink\" title=\"用户使用\"></a>用户使用</h2>","keywords":null,"cover":"https://i.loli.net/2018/09/26/5bab3ffe7a483.png","content":null,"text":"注：由于没有做过游戏开发，也没有使用过unity，所以有问题的地方欢迎在评论指正缓存服务器&emsp;&emsp;Unity的打包流程中最慢的环节就是贴图的压缩。不同的平台，需要把原始贴图压缩成对应平台的压缩贴图格式。iOS和Android平台对应的格式不同。针对这个问题，Uni","link":"","raw":null,"photos":[],"categories":[{"name":"unity","slug":"unity","count":2,"path":"api/categories/unity.json"}],"tags":[{"name":"cacheserver","slug":"cacheserver","count":2,"path":"api/tags/cacheserver.json"}]},{"title":"原型链与继承-JS高级","slug":"the-proptotype-chain-and-inheritance","date":"2018-09-24T04:42:15.000Z","updated":"2018-10-02T15:01:49.428Z","comments":true,"path":"api/articles/the-proptotype-chain-and-inheritance.json","excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>&emsp;&emsp;初学javascript的时候对原型链和继承就一知半解，上半年复习的时候感觉十分良好，直到最近又被问道的时候，还是讲不清楚。自己就又看了一遍JS高级程序设计，力求有更深的理解，彻底搞懂。</p>\n<p>&emsp;&emsp;继承是OO语言中的一个最为人津津乐道的概念。许多OO语言都支持两种继承方式：接口继承和 实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。由于js中方法没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而且其 实现继承主要是依靠原型链来实现的。本段摘自JS高级程序设计。</p>\n<h2 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h2><p>&emsp;&emsp;原型和实例关系：</p>\n<blockquote>\n<p>每个构造函数(constructor)都有一个原型对象(prototype)，原型对象都包含一个指向构造函数的指针，而实例(instance)都包含一个只想原型对象的内部指针。</p>\n</blockquote>\n<p>&emsp;&emsp;如果试图引用对象(instance)的某个属性，首先会在对象内部有没有这个属性，找不到时才会在该对象的原型(prototype)里去寻找这个属性。</p>\n<p>&emsp;&emsp;让一个实例的原型对象指向另一个类型的实例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">thisConstructor.prototype = otherInstance</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们如果要引用thisConstructor构造的实例thisInstance的属性name，</p>","keywords":null,"cover":null,"content":null,"text":"前言&emsp;&emsp;初学javascript的时候对原型链和继承就一知半解，上半年复习的时候感觉十分良好，直到最近又被问道的时候，还是讲不清楚。自己就又看了一遍JS高级程序设计，力求有更深的理解，彻底搞懂。&emsp;&emsp;继承是OO语言中的一个最为人津津乐道的概念","link":"","raw":null,"photos":[],"categories":[{"name":"javascript","slug":"javascript","count":4,"path":"api/categories/javascript.json"}],"tags":[{"name":"原型链","slug":"原型链","count":1,"path":"api/tags/原型链.json"},{"name":"继承","slug":"继承","count":1,"path":"api/tags/继承.json"}]},{"title":"npm包开发","slug":"npmpackage","date":"2018-09-16T09:42:51.000Z","updated":"2018-10-02T15:01:49.428Z","comments":true,"path":"api/articles/npmpackage.json","excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>&emsp;&emsp;之前做项目的时候遇到了一个npm包在typescript程序中无法使用的问题，添加了@types也无法作用。打算自己学习一下npm包的开发。简单的记录一下npm包开发的过程。</p>\n<h2 id=\"必备\"><a href=\"#必备\" class=\"headerlink\" title=\"必备\"></a>必备</h2><p>&emsp;&emsp;1.注册一个npm账号，<a href=\"https://www.npmjs.com/\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/</a></p>\n<p>&emsp;&emsp;2.安装nodejs</p>\n<p>&emsp;&emsp;3.安装git</p>\n<p>&emsp;&emsp;安装过程就不贴了，都很简单，安装教程也很多。</p>\n<h2 id=\"创建npm包\"><a href=\"#创建npm包\" class=\"headerlink\" title=\"创建npm包\"></a>创建npm包</h2><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── bin           <span class=\"comment\">//命令配置</span></span><br><span class=\"line\">├── README<span class=\"selector-class\">.md</span>     <span class=\"comment\">//说明文档</span></span><br><span class=\"line\">├── index<span class=\"selector-class\">.js</span>      <span class=\"comment\">//主入口</span></span><br><span class=\"line\">├── src           <span class=\"comment\">//功能文件</span></span><br><span class=\"line\">├── package<span class=\"selector-class\">.json</span>  <span class=\"comment\">//包信息</span></span><br><span class=\"line\">└── test          <span class=\"comment\">//测试用例</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;大致的目录结构如上，我们在src下新建一个resize.js，然后写上代码：</p>","keywords":null,"cover":"https://i.loli.net/2018/09/17/5b9eed3b8bdf1.png","content":null,"text":"前言&emsp;&emsp;之前做项目的时候遇到了一个npm包在typescript程序中无法使用的问题，添加了@types也无法作用。打算自己学习一下npm包的开发。简单的记录一下npm包开发的过程。必备&emsp;&emsp;1.注册一个npm账号，https://www.n","link":"","raw":null,"photos":[],"categories":[{"name":"npm","slug":"npm","count":1,"path":"api/categories/npm.json"}],"tags":[{"name":"npm","slug":"npm","count":1,"path":"api/tags/npm.json"}]}]}