<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  
  
    <meta name="description" content="web developer.">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    
    Wangx&#39;s blog</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="jumbotron">
  <div class="video">
    
      <div class="video-frame">
        <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
      </div>
    
    <div class="video-media">
      <video playsinline="" autoplay loop muted data-autoplay="" poster="/images/ocean/ocean.png" x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">Wangx&#39;s blog</a></h1>
      <p>Whatever is worth doing is worth doing well.</p>
      <div><img src="/images/wangx.png" class="brand" alt="Wangx&#39;s blog"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>

<div id="landingpage">
  <section class="outer">
  <article class="articles">
    
    <h1 class="page-type-title"></h1>

    
      
        <article id="post-the-proptotype-chain-and-inheritance" class="article article-type-post" itemscope="" itemprop="blogPost">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2018/09/24/the-proptotype-chain-and-inheritance/">原型链与继承-JS高级</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2018/09/24/the-proptotype-chain-and-inheritance/" class="article-date">
  <time datetime="2018-09-24T04:42:15.000Z" itemprop="datePublished">2018-09-24</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/javascript/">javascript</a>
  </div>

      </div>
    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;初学javascript的时候对原型链和继承就一知半解，上半年复习的时候感觉十分良好，直到最近又被问道的时候，还是讲不清楚。自己就又看了一遍JS高级程序设计，力求有更深的理解，彻底搞懂。</p>
<p>&emsp;&emsp;继承是OO语言中的一个最为人津津乐道的概念。许多OO语言都支持两种继承方式：接口继承和 实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。由于js中方法没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而且其 实现继承主要是依靠原型链来实现的。本段摘自JS高级程序设计。</p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>&emsp;&emsp;原型和实例关系：</p>
<blockquote>
<p>每个构造函数(constructor)都有一个原型对象(prototype)，原型对象都包含一个指向构造函数的指针，而实例(instance)都包含一个只想原型对象的内部指针。</p>
</blockquote>
<p>&emsp;&emsp;如果试图引用对象(instance)的某个属性，首先会在对象内部有没有这个属性，找不到时才会在该对象的原型(prototype)里去寻找这个属性。</p>
<p>&emsp;&emsp;让一个实例的原型对象指向另一个类型的实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thisConstructor.prototype = otherInstance</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们如果要引用thisConstructor构造的实例thisInstance的属性name，</p>
<blockquote>
<ol>
<li><p>先在thisInstance自有属性查找</p>
</li>
<li><p>没有找到会在thisInstance.__proto__(thisConstructor.prototype)中找，我们上面将其指向了otherInstance，即我们是在otherInstance中寻找属性name</p>
</li>
<li><p>如果otherInstance中还是没有该属性，程序并不会终止，它将会继续向上去找otherInstance.__proto__(otherConstructor.prototype)的属性，一直到Object的原型对象，即顶端。</p>
<p>查找过程：</p>
<p>thisInstance &gt;&gt; otherInstance &gt;&gt; otherConstructor.prototype ··· &gt;&gt; Object.prototype</p>
</li>
</ol>
</blockquote>
<p>&emsp;&emsp;这样一个查找的过程，就像链条一样，就称作原型链，prototype充当着链接的作用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个简单的例子</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.name = <span class="string">'animal'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tiger</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.age = <span class="string">'tiger'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tiger.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> Tiger();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(instance.name);<span class="comment">// animal</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;了解了原型链，上面的的结果就很明显了，Tiger没有name属性，向上查找到Animal具有name属性，输出。</p>
<p>&emsp;&emsp;如何判断原型和实例的继承呢？一般使用instanceof或isPrototypeOf：</p>
<blockquote>
<ol>
<li><p>使用instanceof运算符：</p>
<p>console.log(instance instanceof Object); // true</p>
<p>console.log(instance instanceof Tiger); // true</p>
<p>console.log(instance instanceof Animal); // true</p>
</li>
</ol>
</blockquote>
<p>&emsp;&emsp;由于原型链的关系，instance可以说是Object、Animal、Tiger中的任何一个实例，所以使用instanceof都会返回true。</p>
<blockquote>
<ol start="2">
<li><p>使用isPrototypeOf()方法：</p>
<p>console.log(Object.prototype.isPrototypeOf(instance));</p>
<p>console.log(Animal.prototype.isPrototypeOf(instance));</p>
<p>console.log(Tiger.prototype.isPrototypeOf(instance));</p>
</li>
</ol>
</blockquote>
<p>&emsp;&emsp;道理和上面的一样。</p>
<h2 id="原型链的问题及解决"><a href="#原型链的问题及解决" class="headerlink" title="原型链的问题及解决"></a>原型链的问题及解决</h2><p>&emsp;&emsp;原型链的设计并不是完美的，它也存在着一些问题：</p>
<blockquote>
<ol>
<li>当原型链中包含引用类型值的原型时，该引用类型值会被所有实例共享。</li>
<li>创建子类型时，不能向父类的构造函数中传参。</li>
</ol>
</blockquote>
<p>&emsp;&emsp;针对原型链的不足，也有解决方案。</p>
<p><strong>经典继承</strong></p>
<p>&emsp;&emsp;为解决原型链中的这两个问题，开始我们使用一种<strong>借用构造函数</strong>(constructor stealing)的技术。其基本思想是在子类型的构造函数内部调用父类的构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.childrens = [<span class="string">'tom'</span>, <span class="string">'bob'</span>, <span class="string">'jack'</span>,<span class="string">'lucy'</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 继承了Father，且向父类传递参数</span></span><br><span class="line">    Father.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> Son();</span><br><span class="line">instance.childrens.push(<span class="string">'reeves'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance.childrens); <span class="comment">// ['tom', 'bob', 'jack','lucy', 'reeves']</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> otherInstance = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="built_in">console</span>.log(otherInstance.childrens); </span><br><span class="line"><span class="comment">// ['tom', 'bob', 'jack','lucy']; 证明引用类型值是独立的</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这种方式保证原型链中引用类型值独立，同时子类型创建时可以向父类型传递参数。但是如果仅用借用构造函数，将会存在方法都在构造函数中定义，函数服用也就不能使用了。而且父类(Father)中定义的方法对子类(Son)而言也是不可见的。所以很少会单独使用这种技术。</p>
<p><strong>组合继承</strong></p>
<p>&emsp;&emsp;也叫做伪经典继承，意思是将原型链和借用构造函数的技术组合。其思路是使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承。这样既通过在原型上定义方法实现函数服用，又能保证每个实例都又自己的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.childrens = [<span class="string">"tom"</span>,<span class="string">"bob"</span>,<span class="string">"jack"</span>,<span class="string">"lucy"</span>];</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//继承实例属性，第一次调用Father()</span></span><br><span class="line">    Father.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承父类方法,第二次调用Father()</span></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();</span><br><span class="line">Son.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son(<span class="string">"reeves"</span>, <span class="number">18</span>);</span><br><span class="line">instance1.childrens.push(<span class="string">"reeves"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.childrens); <span class="comment">// "tom,bob,jack,black,reeves"</span></span><br><span class="line">instance1.sayName(); <span class="comment">// reeves</span></span><br><span class="line">instance1.sayAge(); <span class="comment">// 18</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son(<span class="string">"alex"</span>,<span class="number">19</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.childrens); <span class="comment">// "tom,bob,jack,lucy"</span></span><br><span class="line">instance1.sayName(); <span class="comment">// alex</span></span><br><span class="line">instance1.sayAge(); <span class="comment">// 19</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;组合继承避免了原型链和经典继承的缺陷，组合了二者的有点，是js中最常用的继承模式，它支持instanceof和isPropertyOf()识别实例是否为组合继承创建的对象。另外，组合继承实际上调用了两次父类构造函数，造成了不必要的消耗。</p>
<p><strong>原型继承</strong></p>
<p>&emsp;&emsp;这个方法是由著名的大师Douglas Crockford与2006年提出的，他的想法是借助原型可以基于已有的对象创建新对象，同时不必因此创建自定义类型。其思路是在object()函数内部，先用一个临时的构造函数，再将传入的对象作为这个构造函数的原型，最后返回了这个临时的新实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	F.prototype = o;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;实际上来说，object()对传入的对象进行了一次浅拷贝。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	friends : [<span class="string">"Van"</span>,<span class="string">"Louis"</span>,<span class="string">"Nick"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = object(person);</span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Style"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.friends);<span class="comment">//"Van,Louis,Nick,Rob,Style"</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以作为另一个对象基础的是person对象，于是我们把它传入到object()函数中，然后该函数就会返回一个新对象。这个新对象将person作为原型，因此它的原型中就包含引用类型值属性。 这意味着person。friends不仅属于person所有，而且也会被anotherPerson以及yetAnotherPerson共享。</p>
<p>&emsp;&emsp;ES5中，新增了Object.create()方法规范了原型继承。Object.create()接受两个参数：</p>
<ul>
<li>一个用作新对象原型的对象</li>
<li>(可选)一个为新对象定义额外属性的对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	friends : [<span class="string">"Van"</span>,<span class="string">"Louis"</span>,<span class="string">"Nick"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person);</span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = <span class="built_in">Object</span>.create(person);</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Style"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.friends);<span class="comment">//"Van,Louis,Nick,Rob,Style"</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<strong>object.create()</strong> 只有一个参数时功能与上述object方法相同，它的第二个参数与Object.defineProperties()方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的.以这种方式指定的任何属性都会覆盖原型对象上的同名属性。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	name : <span class="string">"Van"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person, &#123;</span><br><span class="line">	name : &#123;</span><br><span class="line">		value : <span class="string">"Louis"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(anotherPerson.name);<span class="comment">//"Louis"</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;支持Object.create()的浏览器IE9+, Firefox 4+, Safari 5+, Opera 12+ 和 Chrome。需要注意的是，<strong>原型式继承中，包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样。</strong></p>
<h2 id="寄生继承"><a href="#寄生继承" class="headerlink" title="寄生继承"></a>寄生继承</h2><blockquote>
<p>寄生继承思路和构造函数、工厂模式类似，创建一个仅用来封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真的是它做了所有工作一样返回对象。</p>
</blockquote>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span><span class="params">(oriObject)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 通过调用object函数创建一个新对象</span></span><br><span class="line">	<span class="keyword">var</span> another = object(oriObject);</span><br><span class="line">	<span class="comment">// 通过某种方式增强对象</span></span><br><span class="line">	another.sayHi = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">		alert(<span class="string">"hi"</span>);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> another;<span class="comment">//返回这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.wangx.me/2018/09/24/the-proptotype-chain-and-inheritance/" data-id="cjqmd9isn000tzc1bkuki2wgg" class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原型链/">原型链</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/继承/">继承</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        <article id="post-npmpackage" class="article article-type-post" itemscope="" itemprop="blogPost">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2018/09/16/npmpackage/">npm包开发</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2018/09/16/npmpackage/" class="article-date">
  <time datetime="2018-09-16T09:42:51.000Z" itemprop="datePublished">2018-09-16</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/npm/">npm</a>
  </div>

      </div>
    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;之前做项目的时候遇到了一个npm包在typescript程序中无法使用的问题，添加了@types也无法作用。打算自己学习一下npm包的开发。简单的记录一下npm包开发的过程。</p>
<h2 id="必备"><a href="#必备" class="headerlink" title="必备"></a>必备</h2><p>&emsp;&emsp;1.注册一个npm账号，<a href="https://www.npmjs.com/" target="_blank" rel="noopener">https://www.npmjs.com/</a></p>
<p>&emsp;&emsp;2.安装nodejs</p>
<p>&emsp;&emsp;3.安装git</p>
<p>&emsp;&emsp;安装过程就不贴了，都很简单，安装教程也很多。</p>
<h2 id="创建npm包"><a href="#创建npm包" class="headerlink" title="创建npm包"></a>创建npm包</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── bin           <span class="comment">//命令配置</span></span><br><span class="line">├── README<span class="selector-class">.md</span>     <span class="comment">//说明文档</span></span><br><span class="line">├── index<span class="selector-class">.js</span>      <span class="comment">//主入口</span></span><br><span class="line">├── src           <span class="comment">//功能文件</span></span><br><span class="line">├── package<span class="selector-class">.json</span>  <span class="comment">//包信息</span></span><br><span class="line">└── test          <span class="comment">//测试用例</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;大致的目录结构如上，我们在src下新建一个resize.js，然后写上代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Resize = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> sizeName = [<span class="string">'B'</span>, <span class="string">'K'</span>, <span class="string">'M'</span>, <span class="string">'G'</span>, <span class="string">'T'</span>];</span><br><span class="line">    <span class="keyword">if</span> (bytes) &#123;</span><br><span class="line">        <span class="keyword">const</span> e = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.log(bytes) / <span class="built_in">Math</span>.log(<span class="number">1024</span>));</span><br><span class="line">        <span class="keyword">return</span> (bytes / <span class="built_in">Math</span>.pow(<span class="number">1024</span>, <span class="built_in">Math</span>.floor(e))).toFixed(<span class="number">2</span>) + <span class="string">' '</span> + sizeName[e];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Resize;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;然后再在index.js中引用它</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reSize = <span class="built_in">require</span>(<span class="string">'./src/resize.js'</span>);</span><br><span class="line">reSize(<span class="number">18995</span>);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;然后cd到该文件目录下，使用npm init 创建一个package.json。</p>
<p><img src="https://i.loli.net/2018/09/17/5b9eed3b8bdf1.png" alt="package.json"></p>
<h2 id="发布npm包"><a href="#发布npm包" class="headerlink" title="发布npm包"></a>发布npm包</h2><p>&emsp;&emsp;用已经注册好的npm账号添加该项目</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> adduser</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据提示输入账号密码邮箱即可，然后发布。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> publish</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;使用该命令发布该npm包，发布完成后，进入npm个人中心就可以看到自己发布的npm包了。发布时出错可能是注册完npm账号未验证，如果遇到该问题，验证下邮箱重新发布即可。</p>
<p><img src="https://i.loli.net/2018/09/17/5b9eed3b99f63.png" alt="publish"></p>
<p><img src="https://i.loli.net/2018/09/17/5b9eed3b9fc5b.png" alt="npm"></p>
<h2 id="获取npm包"><a href="#获取npm包" class="headerlink" title="获取npm包"></a>获取npm包</h2><p>&emsp;&emsp;下面的就很熟悉了，在创建好的目录下，使用npm install <package-name>即可，我们获取一下刚刚创建好的包。</package-name></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> <span class="keyword">file</span>-<span class="keyword">resize</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;测试一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> reSize <span class="keyword">from</span> <span class="string">'file-resize'</span>;</span><br><span class="line"></span><br><span class="line">reSize(<span class="number">188567</span>); <span class="comment">// 184.14 K</span></span><br></pre></td></tr></table></figure>
<h2 id="更新npm包"><a href="#更新npm包" class="headerlink" title="更新npm包"></a>更新npm包</h2><p>&emsp;&emsp;更新和发布一样，都是使用npm publish，但更新必须修改version，否则会报错。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;学习了一下npm包的创建发布与更新，可以在以后写一些属于自己的npm包。只是简单的学习了一下，并没有系统的去做npm包的开发，npm包开发还包含单元测试等等。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.wangx.me/2018/09/16/npmpackage/" data-id="cjqmd9isl000nzc1b13v84r4a" class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/npm/">npm</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        <article id="post-vueslot" class="article article-type-post" itemscope="" itemprop="blogPost">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2018/09/09/vueslot/">Vue slot(插槽)</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2018/09/09/vueslot/" class="article-date">
  <time datetime="2018-09-09T02:51:57.000Z" itemprop="datePublished">2018-09-09</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/vue/">vue</a>
  </div>

      </div>
    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;插槽是组件的一部分，当时做项目的时候使用到了插槽，并不是很懂，vue官网也没有说明的很清楚，只是说vue实现了一套内容分发的api，\<slot>元素承载分发内容的出口。也就是说插槽是用来分发内容的。那就举个栗子说明一下：</slot></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// app</span><br><span class="line"><span class="tag">&lt;<span class="name">component-a</span>&gt;</span></span><br><span class="line">   这是插槽内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">component-a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// component-a html</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">	hello，word！</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面app中放了一个component-a组件，组件的内容是下面的，这样在浏览器中渲染出来的结果是什么呢？结果是只会渲染出组件中的内容。app中组件标签里的内容被抛弃了。我们在组件中加一下slot，会发现之前写在组件内的内容出来了，这就是插槽的作用，可以分发内容。意思就是如果不使用插槽，在组件标签内写的任何内容都是不会生效的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;component-a&gt;</span><br><span class="line">            这是插槽内容</span><br><span class="line">         &lt;/component-a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        Vue.component(&apos;component-a&apos;,&#123;</span><br><span class="line">            template: `</span><br><span class="line">            &lt;div&gt;hello,word!&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;</span><br><span class="line">            `</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        const app = new Vue(&#123;</span><br><span class="line">            el: &apos;#app&apos;,</span><br><span class="line">            data() &#123;</span><br><span class="line">                return &#123;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个插槽也叫单个插槽。</p>
<h2 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h2><p>&emsp;&emsp;具名插槽就是具有名字的插槽，在组件中给插槽取上名字，然后再组件标签内slot属性填上名字，它就会跟组件内的name一一对应。那么没有名字的就是默认插槽了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">        .border &#123;</span><br><span class="line">            border: 1px solid #e7494b;</span><br><span class="line">        &#125;s</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;component-a&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                默认插槽的内容</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;template slot=&quot;slota&quot;&gt;</span><br><span class="line">                插槽a的内容</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line">            &lt;template slot=&quot;slotb&quot;&gt;</span><br><span class="line">                插槽b的内容</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line">         &lt;/component-a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        Vue.component(&apos;component-a&apos;,&#123;</span><br><span class="line">            template: `</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">              &lt;h2&gt;具名插槽&lt;/h2&gt;</span><br><span class="line">              &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">              &lt;div class=&quot;border&quot;&gt;&lt;/div&gt;</span><br><span class="line">              &lt;slot name=&quot;slota&quot;&gt;&lt;/slot&gt;</span><br><span class="line">              &lt;div class=&quot;border&quot;&gt;&lt;/div&gt;</span><br><span class="line">              &lt;slot name=&quot;slotb&quot;&gt;&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            `</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        const app = new Vue(&#123;</span><br><span class="line">            el: &apos;#app&apos;,</span><br><span class="line">            data() &#123;</span><br><span class="line">                return &#123;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h2><p>&emsp;&emsp;其实上面两种插槽都很简单，一个就是默认插槽不进行命名，具名插槽就是给个名字，然后标签内的内容就会和组件中的名字一一对应，分发内容。</p>
<p>&emsp;&emsp;作用域插槽就是可以把组件标签内的数据在组件元素中使用，我也不知道这样解释合不合理，先看个简单的例子把。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;component-a&gt;</span><br><span class="line">            &lt;template slot-scope=&quot;name&quot;&gt;</span><br><span class="line">                &#123;&#123; name &#125;&#125;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line">        &lt;/component-a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        Vue.component(&apos;component-a&apos;,&#123;</span><br><span class="line">            template: `</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;slot say=&quot;hello&quot;&gt;&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            `</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        const app = new Vue(&#123;</span><br><span class="line">            el: &apos;#app&apos;,</span><br><span class="line">            data() &#123;</span><br><span class="line">                return &#123;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在slot元素上定义一个属性，然后在template添加slot-scope，我们将结果放在标签内展示出来，会看到一个slot属性和值的键值对，这就是作用域插槽。</p>
<p>&emsp;&emsp;再来看看这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;component-a :lists=&quot;list&quot;&gt;</span><br><span class="line">            &lt;template slot-scope=&quot;name&quot;&gt;</span><br><span class="line">                &#123;&#123; name &#125;&#125;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line">        &lt;/component-a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        Vue.component(&apos;component-a&apos;,&#123;</span><br><span class="line">            props: [&apos;lists&apos;],</span><br><span class="line">            template: `</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">               &lt;ol&gt;</span><br><span class="line">                 &lt;li v-for=&quot;item in lists&quot;&gt;</span><br><span class="line">                    &lt;slot :data=&quot;item&quot;&gt;&lt;/slot&gt;</span><br><span class="line">                 &lt;/li&gt;</span><br><span class="line">               &lt;/ol&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            `</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        const app = new Vue(&#123;</span><br><span class="line">            el: &apos;#app&apos;,</span><br><span class="line">            data() &#123;</span><br><span class="line">                return &#123;</span><br><span class="line">                    list: [</span><br><span class="line">                        &#123; no: 1, name: &apos;张三&apos; &#125;,</span><br><span class="line">                        &#123; no: 2, name: &apos;李四&apos; &#125;,</span><br><span class="line">                        &#123; no: 3, name: &apos;王五&apos; &#125;,</span><br><span class="line">                        &#123; no: 4, name: &apos;陈六&apos; &#125;,</span><br><span class="line">                        &#123; no: 5, name: &apos;吴七&apos; &#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果你用过elementui，就会觉得很熟悉，table就是这样的。</p>
<p>&emsp;&emsp;作用域插槽还是比较好用的，这篇文章也只是简单的介绍了插槽的使用和给了一些例子来方便说明。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.wangx.me/2018/09/09/vueslot/" data-id="cjqmd9it40023zc1b7vs3dcwb" class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/slot/">slot</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        <article id="post-vue-sigleway-flow" class="article article-type-post" itemscope="" itemprop="blogPost">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2018/09/02/vue-sigleway-flow/">Vue数据单向流动</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2018/09/02/vue-sigleway-flow/" class="article-date">
  <time datetime="2018-09-02T05:33:00.000Z" itemprop="datePublished">2018-09-02</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/vue/">vue</a>
  </div>

      </div>
    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><hr>
<p>  &emsp;&emsp;官方说法叫单向数据流，意思是父级prop的更新会向下流动到子组件中，但是反过来是不行的。为的是防止子组件修改父组件的状态。但是实际开发中我们可能会遇到以下两种情况：</p>
<p>&emsp;&emsp;1. 需要使用并修改父组件传递的数据，但不需要回传给父组件</p>
<p>&emsp;&emsp;2. 需要使用并修改父组件传递的数据并回传给父组件</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>&emsp;&emsp;如果我们将父组件prop的数据直接在input中进行了修改，vue在控制台中给出警告，栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// html</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; title &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;conponent-son :title=&quot;title&quot;&gt;&lt;/conponent-son&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">        Vue.component(&apos;conponent-son&apos;, &#123;</span><br><span class="line">            props: [&apos;title&apos;],</span><br><span class="line">            template: `&lt;div&gt;</span><br><span class="line">                &lt;input type=&quot;text&quot; v-model=&quot;title&quot;&gt;</span><br><span class="line">            &lt;/div&gt;`</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        const app = new Vue(&#123;</span><br><span class="line">            el: &apos;#app&apos;,</span><br><span class="line">            data() &#123;</span><br><span class="line">                return &#123;</span><br><span class="line">                    title: &apos;文章&apos;,</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;,</span><br><span class="line">            mounted() &#123;</span><br><span class="line">                // 模拟异步加载数据</span><br><span class="line">                window.setTimeout(()=&gt;&#123;</span><br><span class="line">                    this.title = &apos;文章&apos;;</span><br><span class="line">                &#125;,100);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2018/09/02/5b8bb4fc4f1e6.png" alt="错误"></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><strong>1.使用父组件数据，修改不回传</strong></p>
<p>&emsp;&emsp;这种情况通常是需要修改已经存在的文章或者其他的个人信息之类的表单数据，通过父组件获取数据，传给子组件，子组件需要进行修改，然后直接请求接口修改信息，不需要回传给父组件再请求接口修改。这种方式的解决方法再vue给出的警告已经说的很清楚了，使用data或者计算方法去代替这种操作。先看第一种data方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;conponent-son&apos;, &#123;</span><br><span class="line">        props: [&apos;title&apos;],</span><br><span class="line">        data()&#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                currentTitle: this.title</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">        template: `&lt;div&gt;</span><br><span class="line">            &lt;input type=&quot;text&quot; v-model=&quot;currentTitle&quot;&gt;</span><br><span class="line">        &lt;/div&gt;`</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这种方法主要是通过组件的一个局部变量，将props的数据赋值给局部变量currentTitle，这样就不会存在数据回流的情况了，因为我们是修改的并不是原数据。另外也可以使用计算属性getter&amp;setter，不推荐，毕竟有简单的方法实现了，何必钻牛角尖呢。</p>
<p><strong>2.使用父组件数据需要回传</strong></p>
<p>&emsp;&emsp;这种情况呢就跟上面的有一定区别，在于通过父组件获取数据后，传给子组件修改，需要通过父组件请求接口完成数据的更改。所以需要回传，但是这种操作在vue看来是不安全的，因为子组件去修改了父组件的数据状态，有时候我们不得不这样做比如所说的这种情况。栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; title &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;conponent-son :title=&quot;title&quot; @input-done=&quot;receiveInput&quot;&gt;&lt;/conponent-son&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">Vue.component(&apos;conponent-son&apos;, &#123;</span><br><span class="line">        props: [&apos;title&apos;],</span><br><span class="line">        data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                currentTitle: this.title</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">        template: `&lt;div&gt;</span><br><span class="line">            &lt;input type=&quot;text&quot; v-model=&quot;currentTitle&quot; @blur=&quot;commitInput&quot;&gt;</span><br><span class="line">        &lt;/div&gt;`,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            commitInput() &#123;</span><br><span class="line">                this.$emit(&apos;input-done&apos;, this.currentTitle);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    const app = new Vue(&#123;</span><br><span class="line">        el: &apos;#app&apos;,</span><br><span class="line">        data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                title: &apos;文章&apos;,</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">        mounted() &#123;</span><br><span class="line">            // 模拟异步加载数据</span><br><span class="line">            window.setTimeout(() =&gt; &#123;</span><br><span class="line">                this.title = &apos;文章&apos;;</span><br><span class="line">            &#125;,100);</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            receiveInput(newTitle) &#123;</span><br><span class="line">                this.title = newTitle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;验证了之后发现直接修改原数据还是会给warning，所以还是需要用到第一种解决方案来处理一下数据，折中，毕竟对于强迫症来说一直给wraning也挺糟的，虽然用户感觉不到，但我们还是得处理一下。</p>
<p>&emsp;&emsp;主要就是添加自定义事件input-done，然后在父组件中监听该事件，输入完成，焦点离开后，就触发该提交事件，父组件监听到该事件就会将数据修改为newTitle，这样就完成了提交。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;数据单向流动就是确保数据的安全性，可以向下但不能(是不建议)向上，因为向上可能会涉及一些问题，所以有时候有需求的时候，麻烦还是得麻烦一下。因为这样做虽然麻烦了，但是避免了修改原数据，保证了数据的安全、可靠，值得推荐使用(我当然不是觉得一堆warning看着难受:)。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.wangx.me/2018/09/02/vue-sigleway-flow/" data-id="cjqmd9isz001pzc1b6fh7g244" class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/component/">component</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/单向流动/">单向流动</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        <article id="post-vuedoublesidedbind" class="article article-type-post" itemscope="" itemprop="blogPost">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2018/08/26/vuedoublesidedbind/">双向绑定</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2018/08/26/vuedoublesidedbind/" class="article-date">
  <time datetime="2018-08-26T02:24:55.000Z" itemprop="datePublished">2018-08-26</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/vue/">vue</a>
  </div>

      </div>
    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <h2 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h2><p>&emsp;&emsp;数据的双向绑定可以说是MVVM框架的核心思想，MVVM框架包括三个部分，Model、View和ViewModel，分别指数据、视图、ViewModel可以说是前二者的连接者，二者通过它实现数据的双向绑定。以Vue为例，先看下Vue官网数据绑定的示意图：</p>
<p><img src="https://i.loli.net/2018/08/26/5b827f69c1a85.png" alt="数据绑定"></p>
<p>&emsp;&emsp;<em>这张图想表达的是，对象a下的属性b定义了getter、setter对属性进行劫持，当属性值改变时就会notify通知watch对象，而watch对象则会notify到view更新。反之，在视图改变数据时，也会触发订阅者watch，更新数据到data中。这样的model能实时响应view上的数据变化，view实时响应model的数据变化，这样的一个过程就叫数据的双向绑定。</em></p>
<p>&emsp;&emsp;Vue是通过ES5中Object.defineProperty()这个方法来实现getter、setter对数据进行劫持，所以要运行Vue的运行环境需支持ES5。</p>
<h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h2><p>&emsp;&emsp;这是一个ES5的方法，可以在一个对象上定义一个新属性或用来修改一个已经存在的属性，并返回该对象。目前对象的属性描述符有两种主要形式：此数据描述符和存取描述符。</p>
<p>&emsp;&emsp;<em>数据描述符是一个拥有一个可写或不可写值的属性</em></p>
<p>&emsp;&emsp;<em>存取描述符是由一对getter-setter函数功能来描述的属性</em></p>
<p>&emsp;&emsp;描述符只能是以上两种之一，不可能同时拥有这两种。描述符属性包括：configurable(可配置性，这又为true时才能设置)、Writable(是否可写)、Enumerable(是否可枚举)、get(给属性提供getter)、setter(给属性提供setter)。看下这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">'vue'</span> &#125;;</span><br><span class="line"><span class="comment">// 数据描述符</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">"age"</span>, &#123;</span><br><span class="line">    value: <span class="number">11</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据存取符</span></span><br><span class="line"><span class="keyword">let</span> objValue = &#123; <span class="attr">name</span>: <span class="string">'data'</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(objValue, <span class="string">"age"</span>, &#123;</span><br><span class="line">    get: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'getter'</span>);</span><br><span class="line">        <span class="keyword">return</span> objValue;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'setter'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line">objValue.age = <span class="number">18</span>; <span class="comment">// setter</span></span><br><span class="line"><span class="built_in">console</span>.log(objValue.age); <span class="comment">// getter</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;前面已经提到了，数据描述符和存取描述符二者只能有一，虽然上诉几种属性二者均有，但是实际上writable不能和get、set同时存在。这就是Object.defineProperty方法的用法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;Vue通过Object.defineProperty()方法实现对数据的劫持，给每个实例数据添加了getter、setter，仅仅是这样还不能够实现数据的双向绑定。要实现双向绑定还需要对属性的get、set进行监听，还需要实现notify。也就是需要实现订阅器存放订阅者watcher，它可以将view和model数据联系起来，数据变化触发update更新视图。这就是数据双向绑定的大概思路。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.wangx.me/2018/08/26/vuedoublesidedbind/" data-id="cjqmd9it1001vzc1bp1h58miq" class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/双向绑定/">双向绑定</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
  </article>
  
  
    <nav class="page-nav">
      
      <a class="extend prev" rel="prev" href="/page/3/">Newer posts</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/">Older posts</a>
    </nav>
  
</section>
</div>

  <footer class="footer">
  
  <div class="outer">
    <ul class="list-inline">
      <li>&copy; 2019 Wangx&#39;s blog</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <!-- <li>Theme  <a href="https://zhwangart.github.io">zhwangart</a></li> -->
      <!--
      <li><a href="/">wangx</a></li>
      -->
    </ul>
  </div>
</footer>
</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>

<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/wangx.png" alt="Wangx&#39;s blog"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">主页</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">文章</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">相册</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">关于</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>

<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
    </li>
  </ul>
</nav>

<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>
  <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>


  <script src="/fancybox/jquery.fancybox.min.js"></script>



  <script src="/js/search.js"></script>


<script src="/js/ocean.js"></script>

</body>
</html>